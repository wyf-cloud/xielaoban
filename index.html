<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>标书拯救者</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body, html, #root {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; 
      }

      @keyframes ping_slow_once {
        0%, 100% { transform: scale(1); opacity: 0; }
        10%, 80% { transform: scale(1.2); opacity: 1; }
      }
      .animate-ping_slow_once {
        animation: ping_slow_once 0.7s cubic-bezier(0, 0, 0.2, 1) forwards;
      }

      @keyframes typing-bob {
        0%, 100% { transform: translateY(0) translateX(-50%); }
        50% { transform: translateY(-2px) translateX(-50%); }
      }
      .animate-typing-bob {
        animation: typing-bob 1s infinite ease-in-out;
      }

      @keyframes shake {
        0%, 100% { transform: translateX(-50%) translateY(-50%) rotate(0deg); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) translateY(-50%) rotate(-2deg); }
        20%, 40%, 60%, 80% { transform: translateX(-50%) translateY(-50%) rotate(2deg); }
      }
      .animate-shake {
        animation: shake 0.3s linear;
      }

      @keyframes screen-pulse-effect {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 1; }
      }
      .animate-screen-pulse {
        animation: screen-pulse-effect 1.5s infinite cubic-bezier(0.4, 0, 0.6, 1);
      }

      @keyframes boss-enter-left {
        from { left: -150px; opacity: 0; } 
        to { left: 15%; opacity: 1; } 
      }
      .animate-boss-enter-left { animation: boss-enter-left 1s ease-out forwards; }

      @keyframes boss-enter-right {
        from { left: calc(100% + 150px); opacity: 0; }
        to { left: 85%; opacity: 1; } 
      }
      .animate-boss-enter-right { animation: boss-enter-right 1s ease-out forwards; }
      
      @keyframes boss-exit-left {
        from { left: 15%; opacity: 1; }
        to { left: -150px; opacity: 0; }
      }
      .animate-boss-exit-left { animation: boss-exit-left 1s ease-in forwards; }

      @keyframes boss-exit-right {
        from { left: 85%; opacity: 1; }
        to { left: calc(100% + 150px); opacity: 0; }
      }
      .animate-boss-exit-right { animation: boss-exit-right 1s ease-in forwards; }

      @keyframes boss-scold-shake {
        0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
        25% { transform: translate(-50%, -50%) rotate(-2deg); }
        75% { transform: translate(-50%, -50%) rotate(2deg); }
      }
      .animate-boss-scold-shake {
        animation: boss-scold-shake 0.3s linear infinite;
      }

      @keyframes speech-bubble-appear {
        from { opacity: 0; transform: translateY(10px) scale(0.9); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      .animate-speech-bubble-appear {
        animation: speech-bubble-appear 0.3s ease-out forwards;
      }

      @keyframes dynamic-text-gradient {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      .animate-dynamic-text-gradient {
        background-image: linear-gradient(to right, #10b981, #3b82f6, #f59e0b, #ec4899, #10b981);
        background-size: 300% auto;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: dynamic-text-gradient 8s linear infinite;
      }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.1.0",
    "react-dom/client": "https://esm.sh/react-dom@19.1.0/client",
    "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
    "react/": "https://esm.sh/react@^19.1.0/"
  }
}
</script>
</head>
<body>
    <noscript>你需要启用 JavaScript 来运行此应用。</noscript>
    <div id="root"></div>

    <script type="module">
      import React, { useState, useEffect, useCallback, memo, useRef } from 'react';
      import ReactDOM from 'react-dom/client';

      const GameStatus = { Idle: 'idle', Setup: 'setup', Playing: 'playing', Won: 'won', Lost: 'lost' };
      const DifficultyLevel = { Easy: 'easy', Normal: 'normal', Hard: 'hard' };

      const DIFFICULTY_SETTINGS = {
        [DifficultyLevel.Easy]: {
          initialTime: 180, baseProgress: 2.0, biteSlowdown: 0.7, mosquitoSpawnInitial: 2200,
          mosquitoSpawnMin: 1000, mosquitoSpeed: 1.2, bossSpawnChance: 0.08, bossScoldFactor: 0.8,
          bossDuration: 15000, bossScoldStartDelay: 2000, mosquitoBiteScorePenalty: 1,
          redMosquitoSpawnChance: 0.10, redMosquitoSpeedMultiplier: 1.3, redMosquitoProgressPenalty: 3,
        },
        [DifficultyLevel.Normal]: {
          initialTime: 120, baseProgress: 1.5, biteSlowdown: 0.5, mosquitoSpawnInitial: 1500,
          mosquitoSpawnMin: 600, mosquitoSpeed: 1.5, bossSpawnChance: 0.15, bossScoldFactor: 0.6,
          bossDuration: 12000, bossScoldStartDelay: 1500, mosquitoBiteScorePenalty: 2,
          redMosquitoSpawnChance: 0.15, redMosquitoSpeedMultiplier: 1.5, redMosquitoProgressPenalty: 5,
        },
        [DifficultyLevel.Hard]: {
          initialTime: 90, baseProgress: 1.2, biteSlowdown: 0.3, mosquitoSpawnInitial: 1000,
          mosquitoSpawnMin: 400, mosquitoSpeed: 1.8, bossSpawnChance: 0.25, bossScoldFactor: 0.4,
          bossDuration: 10000, bossScoldStartDelay: 1000, mosquitoBiteScorePenalty: 3,
          redMosquitoSpawnChance: 0.20, redMosquitoSpeedMultiplier: 1.7, redMosquitoProgressPenalty: 7,
        },
      };

      const JSONBIN_API_URL_BASE = 'https://api.jsonbin.io/v3/b';
      const JSONBIN_BIN_ID = '6842b3b78561e97a5020422f'; 
      const JSONBIN_MASTER_KEY = '$2a$10$Qx80rURsF9e4Z0JPbTBsdu3bZv.0.j/8J3qFPiU0Lu.n0MhyKlQGi'; 
      const LEADERBOARD_API_READ_URL = `${JSONBIN_API_URL_BASE}/${JSONBIN_BIN_ID}/latest`;
      const LEADERBOARD_API_WRITE_URL = `${JSONBIN_API_URL_BASE}/${JSONBIN_BIN_ID}`;
      const LEADERBOARD_KEY_LOCAL_FALLBACK = 'tenderRescuerLeaderboard_local_v2'; 
      const MAX_LEADERBOARD_ENTRIES = 30;

      // (Leaderboard functions remain the same)
      async function loadLeaderboardFromAPI() {
        if (JSONBIN_BIN_ID === 'YOUR_BIN_ID_HERE' || JSONBIN_MASTER_KEY === 'YOUR_MASTER_KEY_HERE') { 
          console.warn("JSONBin API not configured. Skipping API load for leaderboard.");
          return null;
        }
        try {
          const response = await fetch(LEADERBOARD_API_READ_URL, {
            method: 'GET',
            headers: { 'X-Master-Key': JSONBIN_MASTER_KEY },
          });
          if (response.status === 404) { 
            console.log("Leaderboard bin not found on API, likely first run. Returning empty.");
            return []; 
          }
          if (!response.ok) {
            console.error(`Failed to load leaderboard from API: ${response.status} ${response.statusText}`);
            const errorBody = await response.text(); 
            console.error("Error body:", errorBody);
            return null;
          }
          const data = await response.json();
          const leaderboardData = data.record || data; 
          if (Array.isArray(leaderboardData) && leaderboardData.every(item => typeof item === 'object' && item !== null && 'name' in item && typeof item.name === 'string' && 'score' in item && typeof item.score === 'number')) {
            return leaderboardData;
          }
          console.warn("Loaded data from API is not in the expected format:", leaderboardData);
          return []; 
        } catch (error) {
          console.error("Error loading leaderboard from API:", error);
          return null;
        }
      }
      function loadLeaderboardFromLocalStorage() {
        try {
          const data = localStorage.getItem(LEADERBOARD_KEY_LOCAL_FALLBACK);
          if (data) {
            const parsedData = JSON.parse(data);
            if (Array.isArray(parsedData) && parsedData.every(item => typeof item === 'object' && item !== null && 'name' in item && typeof item.name === 'string' && 'score' in item && typeof item.score === 'number')) {
              return parsedData;
            }
          }
        } catch (error) {
          console.error("Failed to load leaderboard from localStorage:", error);
        }
        return [];
      }
      async function saveLeaderboardToAPI(leaderboard) {
        if (JSONBIN_BIN_ID === 'YOUR_BIN_ID_HERE' || JSONBIN_MASTER_KEY === 'YOUR_MASTER_KEY_HERE') { 
          console.warn("JSONBin API not configured. Skipping API save for leaderboard.");
          return false;
        }
        try {
          const response = await fetch(LEADERBOARD_API_WRITE_URL, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_MASTER_KEY, },
            body: JSON.stringify(leaderboard),
          });
          if (!response.ok) { 
              console.error(`Failed to save leaderboard to API: ${response.status} ${response.statusText}`);
              const errorBody = await response.text(); 
              console.error("Error body:", errorBody);
              return false; 
          }
          console.log("Leaderboard saved to API successfully.");
          return true;
        } catch (error) { console.error("Error saving leaderboard to API:", error); return false; }
      }
      function saveLeaderboardToLocalStorage(leaderboard) {
        try { localStorage.setItem(LEADERBOARD_KEY_LOCAL_FALLBACK, JSON.stringify(leaderboard)); }
        catch (error) { console.error("Failed to save leaderboard to localStorage:", error); }
      }
      async function initializeLeaderboard() {
        let apiLeaderboard = await loadLeaderboardFromAPI();
        if (apiLeaderboard !== null) { saveLeaderboardToLocalStorage(apiLeaderboard); return apiLeaderboard; }
        console.log("Falling back to localStorage for leaderboard.");
        return loadLeaderboardFromLocalStorage();
      }
      const addScoreToLeaderboardList = (name, score, currentLeaderboard) => {
        const newLeaderboard = [...currentLeaderboard, { name: name || "匿名玩家", score }];
        newLeaderboard.sort((a, b) => b.score - a.score);
        return newLeaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
      };

      const SCOLD_MESSAGES = [
        (name) => `${name}, 这标书啥时候能好？抓紧点！`,
        (name) => `我看你这进度条，是不是又摸鱼了，${name}？`,
        (name) => `客户等着呢，${name}，速度！`,
        (name) => `还有时间发呆？${name}，不想干了？`,
        (name) => `这质量不行啊，${name}，返工！...开玩笑的，快点就行。`,
        (name) => `${name}，你怎么写的这么慢，你是猪吗？效率！`,
        (name) => `喂，${name}！这进度是认真的吗？蚂蚁搬家都比你快！`,
        (name) => `我说${name}，这都几点了？标书还在这磨蹭？`,
        (name) => `${name}，deadline都要到了，你这键盘长蘑菇了吗？`,
        (name) => `我看你不是在写标书，${name}，你是在绣花吧？快点！`,
        (name) => `搞快点，${name}！再慢下去，黄花菜都凉了！`,
        (name) => `${name}，这份标书是给下个世纪的客户准备的吗？`,
        (name) => `打起精神来，${name}！这进度条看得我血压都高了！`,
        (name) => `能不能行啊，${name}？不行我换人了啊！（拍桌）`,
        (name) => `${name}，给你泡的咖啡都冷了，标书还没一半？`,
        (name) => `其他人标书都写三份了，${name}，你这份还没搞定？`
      ];

      // (UI Components like TimerDisplay, ProgressBar, TenderWriter, MosquitoComponent, BossComponent, GameOverlay remain the same)
      const TimerDisplay = ({ timeLeft }) => { 
        if (timeLeft === null) { return React.createElement('div', { className: 'font-mono text-lg text-green-300' }, '剩余时间: --:--'); }
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        const timeClass = `font-mono text-lg ${timeLeft <= 10 && timeLeft > 0 ? 'text-red-400 animate-pulse' : 'text-green-300'}`;
        return React.createElement('div', { className: timeClass }, `剩余时间: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);
      };
      const ProgressBar = ({ progress }) => { 
        const displayProgress = Math.max(0, Math.min(100, progress));
        return React.createElement('div', { className: "mt-3" },
          React.createElement('div', { className: "flex justify-between mb-1" }, React.createElement('span', { className: "text-sm font-medium text-sky-200" }, "标书进度"), React.createElement('span', { className: "text-sm font-medium text-sky-200" }, `${Math.round(displayProgress)}%`)),
          React.createElement('div', { className: "w-full bg-slate-600 rounded-full h-4 md:h-5 shadow-inner" }, React.createElement('div', { className: "bg-gradient-to-r from-sky-500 to-cyan-400 h-4 md:h-5 rounded-full transition-all duration-150 ease-linear", style: { width: `${displayProgress}%` }}))
        );
      };
      const TenderWriter = ({ playerName, position, isBitten, isTyping }) => { 
        const writerBaseClasses = "absolute transform -translate-x-1/2 -translate-y-1/2 p-2 transition-all duration-200";
        const writerAnimationClasses = `${isTyping ? 'animate-typing-bob' : ''} ${isBitten ? 'animate-shake' : ''}`;
        const typingText = isTyping ? `${playerName} 撰写中...` : '已完成!';
        return React.createElement('div', { className: `${writerBaseClasses} ${writerAnimationClasses}`, style: { left: `${position.x}%`, top: `${position.y}%`, zIndex: 20 }},
          React.createElement('div', { className: "bg-slate-200/70 p-3 rounded-lg shadow-lg w-28 h-36 md:w-32 md:h-40 relative backdrop-blur-sm" },
            React.createElement('div', { className: `absolute top-2 left-1/2 -translate-x-1/2 w-10 h-10 md:w-12 md:h-12 bg-pink-300 rounded-full border-2 border-slate-700` }),
            React.createElement('div', { className: `absolute top-10 left-1/2 -translate-x-1/2 w-16 h-20 md:w-20 md:h-24 bg-blue-500 rounded-md border-2 border-slate-700` }),
            React.createElement('div', { className: "absolute bottom-[-15px] left-1/2 -translate-x-1/2 w-36 h-10 md:w-40 bg-yellow-700 rounded-t-md border-2 border-slate-800 shadow-md" }),
            React.createElement('div', { className: "absolute bottom-[10px] left-1/2 -translate-x-1/2 w-20 h-16 md:w-24 md:h-20 bg-slate-800 rounded-sm border-2 border-slate-500 flex items-center justify-center p-1" },
              React.createElement('div', { className: `w-full h-full bg-sky-200 ${isTyping ? 'animate-screen-pulse' : ''} text-xs text-slate-900 p-1 overflow-hidden flex items-center justify-center font-semibold` }, typingText )
            ),
            isBitten && React.createElement('div', { className: "absolute -top-6 left-1/2 -translate-x-1/2 bg-red-500 text-white text-xs px-2 py-1 rounded-full shadow-lg animate-ping_slow_once" }, "哎哟!")
          )
        );
      };
      const MosquitoComponent = memo(({ mosquito, onSwat, onReachTarget, targetPosition, targetRadius, speed }) => { 
        const [currentPosition, setCurrentPosition] = useState({ x: mosquito.x, y: mosquito.y });
        const MOSQUITO_WIGGLE_FACTOR = 0.5; 
        useEffect(() => {
          if (mosquito.isSwatted) return; 
          const moveInterval = setInterval(() => {
            setCurrentPosition(prevPos => {
              const dx = targetPosition.x - prevPos.x;
              const dy = targetPosition.y - prevPos.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < targetRadius) { onReachTarget(mosquito); clearInterval(moveInterval); return prevPos; }
              const wiggleX = (Math.random() - 0.5) * MOSQUITO_WIGGLE_FACTOR * speed * 5;
              const wiggleY = (Math.random() - 0.5) * MOSQUITO_WIGGLE_FACTOR * speed * 5;
              const moveX = (dx / dist) * speed + wiggleX;
              const moveY = (dy / dist) * speed + wiggleY;
              let newX = prevPos.x + moveX; let newY = prevPos.y + moveY;
              const margin = 100; 
              newX = Math.max(-margin, Math.min(window.innerWidth + margin, newX));
              newY = Math.max(-margin, Math.min(window.innerHeight + margin, newY));
              return { x: newX, y: newY };
            });
          }, 30); 
          return () => clearInterval(moveInterval);
        }, [mosquito, onReachTarget, targetPosition.x, targetPosition.y, targetRadius, speed]); 

        const isRed = mosquito.type === 'red';
        const bodyFill = isRed ? "#C53030" : "#333"; const headFill = isRed ? "#A02020" : "#222";
        const wingFill = isRed ? "rgba(239, 68, 68, 0.4)" : "rgba(0,0,0,0.3)"; const legStroke = isRed ? "#7F1D1D" : "#111";
        const liveMosquitoContent = React.createElement('svg', { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", className: "w-full h-full" }, React.createElement('ellipse', { cx: "50", cy: "50", rx: "15", ry: "25", fill: bodyFill }), React.createElement('circle', { cx: "50", cy: "25", r: "10", fill: headFill }), React.createElement('ellipse', { cx: "30", cy: "45", rx: "25", ry: "10", transform: "rotate(-20 30 45)", fill: wingFill }), React.createElement('ellipse', { cx: "70", cy: "45", rx: "25", ry: "10", transform: "rotate(20 70 45)", fill: wingFill }), React.createElement('line', { x1: "40", y1: "60", x2: "20", y2: "70", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "40", y1: "70", x2: "20", y2: "85", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "60", y1: "60", x2: "80", y2: "70", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "60", y1: "70", x2: "80", y2: "85", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "50", y1: "15", x2: "50", y2: "0", stroke: legStroke, strokeWidth: "3" }));
        const swattedMosquitoContent = React.createElement('div', { className: "absolute inset-0 flex items-center justify-center" }, React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "rgba(200, 38, 38, 0.95)", className: "w-12 h-12" }, React.createElement('path', { d: "M15.901 8.086a.75.75 0 00-1.06-1.06L12 9.879l-2.84-2.853a.75.75 0 10-1.061 1.06L10.939 12l-2.853 2.84a.75.75 0 001.06 1.061L12 13.061l2.84 2.853a.75.75 0 101.061-1.06L13.061 12l2.84-2.854zM2.193 8.617a10.423 10.423 0 01-.159-1.281A10.453 10.453 0 011.51 4.82a1.51 1.51 0 012.036-1.15c.44.198.832.457 1.185.765C5.594 3.64 6.36 3.056 7.216 2.61c.492-.254 1.01-.437 1.548-.55A10.45 10.45 0 0112.001 2c1.565 0 3.076.344 4.438.97.506.21 1 .485 1.442.818.93.702 1.524 1.468 1.93 2.332.21.457.353.93.434 1.419a10.453 10.453 0 010 3.038 11.75 11.75 0 01-.434 1.42c-.406.863-.999 1.63-1.93 2.331a4.14 4.14 0 01-1.442.818A10.45 10.45 0 0112.001 22a10.45 10.45 0 01-3.237-.56c-.538-.113-1.056-.296-1.548-.55-.855-.446-1.622-1.03-2.483-1.826-.353-.308-.746-.567-1.185-.765a1.51 1.51 0 01-1.15-2.036c.11-.59.154-1.185.159-1.781a10.428 10.428 0 00-.159-1.281l-.001-.001z" }) ));
        return React.createElement('div', { className: "absolute w-14 h-14 transform -translate-x-1/2 -translate-y-1/2 cursor-pointer drop-shadow-lg", style: { left: `${currentPosition.x}px`, top: `${currentPosition.y}px`, zIndex: mosquito.isSwatted ? 15 : 25 }, onClick: () => { if (!mosquito.isSwatted) { onSwat(mosquito.id); } } }, !mosquito.isSwatted ? liveMosquitoContent : swattedMosquitoContent );
      });
      const BossComponent = ({ bossData, onClick, playerName }) => { 
          const [scoldMessage, setScoldMessage] = useState(''); const [_tick, setTick] = useState(0); 
          const wasPreviouslyScoldingRef = useRef(false); const initialEntryStylesAppliedRef = useRef(false); const prevBossIdRef = useRef(null);
          useEffect(() => { if (bossData && prevBossIdRef.current !== bossData.id) { initialEntryStylesAppliedRef.current = false; prevBossIdRef.current = bossData.id;}}, [bossData]);
          useEffect(() => {
            if (!bossData.isVisible || bossData.clickedAway) { initialEntryStylesAppliedRef.current = false; return; }
            const timerId = setInterval(() => { const now = Date.now(); const currentlyInScoldWindow = now >= bossData.scoldStartTime && now < bossData.scoldEndTime; if (currentlyInScoldWindow || (wasPreviouslyScoldingRef.current && !currentlyInScoldWindow) || (!wasPreviouslyScoldingRef.current && currentlyInScoldWindow)) { setTick(t => t + 1); } if (now >= bossData.scoldEndTime) clearInterval(timerId); }, 500); 
            return () => clearInterval(timerId);
          }, [bossData.isVisible, bossData.clickedAway, bossData.scoldStartTime, bossData.scoldEndTime]);
          const isScoldingPeriodActive = bossData.isVisible && !bossData.clickedAway && Date.now() >= bossData.scoldStartTime && Date.now() < bossData.scoldEndTime;
          useEffect(() => { wasPreviouslyScoldingRef.current = isScoldingPeriodActive; }, [isScoldingPeriodActive]);
          useEffect(() => {
            let messageChangeIntervalId;
            if (isScoldingPeriodActive) { const pickNewMessage = () => { const randomScoldFn = SCOLD_MESSAGES[Math.floor(Math.random() * SCOLD_MESSAGES.length)]; setScoldMessage(randomScoldFn(playerName)); }; if (scoldMessage === '' || !wasPreviouslyScoldingRef.current) pickNewMessage(); messageChangeIntervalId = setInterval(() => { if (Date.now() < bossData.scoldEndTime) pickNewMessage(); else clearInterval(messageChangeIntervalId); }, 4000);
            } else { setScoldMessage(''); } return () => { if (messageChangeIntervalId) clearInterval(messageChangeIntervalId); };
          }, [isScoldingPeriodActive, playerName, bossData.id, bossData.scoldEndTime]); 
          
          if (!bossData) return null;
          
          let determinedAnimationClass = '';
          const appSaysBossShouldBeVisible = bossData.isVisible && !bossData.clickedAway;

          if (bossData.clickedAway) { 
            determinedAnimationClass = bossData.slideDirection === 'left' ? 'animate-boss-exit-left' : 'animate-boss-exit-right';
            initialEntryStylesAppliedRef.current = false; 
          } else if (appSaysBossShouldBeVisible) { 
            determinedAnimationClass = bossData.slideDirection === 'left' ? 'animate-boss-enter-left' : 'animate-boss-enter-right';
          } else { 
            determinedAnimationClass = bossData.slideDirection === 'left' ? 'animate-boss-exit-left' : 'animate-boss-exit-right';
            initialEntryStylesAppliedRef.current = false; 
          }
          
          const style = { top: `${bossData.y}px`, zIndex: 35, transform: `translate(-50%, -50%) ${isScoldingPeriodActive ? 'rotate(1deg)' : ''}`};
          
          if (appSaysBossShouldBeVisible && determinedAnimationClass.includes('enter') && !initialEntryStylesAppliedRef.current) { 
            style.opacity = 0; 
            style.left = bossData.slideDirection === 'right' ? `calc(100% + 150px)` : `-150px`; 
            initialEntryStylesAppliedRef.current = true; 
          }

          return React.createElement('div', { className: `absolute w-32 h-48 md:w-36 md:h-52 transform cursor-pointer p-2 ${isScoldingPeriodActive ? 'animate-boss-scold-shake' : ''} ${determinedAnimationClass}`, style: style, onClick: () => onClick(bossData.id) },
            React.createElement('div', { className: "w-full h-full bg-slate-700 rounded-lg border-4 border-slate-800 shadow-2xl relative flex flex-col items-center p-2" },
              React.createElement('div', { className: "w-16 h-16 bg-orange-300 rounded-full border-2 border-slate-900 mt-1" }), React.createElement('div', { className: "w-4 h-10 bg-red-600 mt-1 rounded-sm transform skew-y-6 border border-black" }), 
              React.createElement('div', { className: "w-24 h-20 bg-slate-600 rounded-md mt-[-10px] border-2 border-slate-900" }), React.createElement('div', { className: "absolute -top-5 left-1/2 -translate-x-1/2 bg-black text-white px-3 py-1 text-sm rounded-full shadow-md" }, "老板"),
              isScoldingPeriodActive && scoldMessage && React.createElement('div', { className: "absolute -top-20 left-1/2 -translate-x-1/2 min-w-[120px] max-w-[220px] bg-white p-2 rounded-lg shadow-xl border-2 border-gray-400 animate-speech-bubble-appear z-10" },
                React.createElement('p', { className: "text-sm text-gray-800 font-semibold" }, scoldMessage), React.createElement('div', { className: "absolute bottom-[-10px] left-1/2 -translate-x-1/2 w-0 h-0 border-l-[10px] border-l-transparent border-r-[10px] border-r-transparent border-t-[10px] border-t-white" })
          )));
      };
      const GameOverlay = ({ status, score, onSubmitSetup, onReturnToSetup, leaderboard }) => { 
        const [localName, setLocalName] = useState(''); const [localDifficulty, setLocalDifficulty] = useState(DifficultyLevel.Normal);
        let title = ''; let content; const difficultyOptions = [{ label: '简单', value: DifficultyLevel.Easy }, { label: '一般', value: DifficultyLevel.Normal }, { label: '困难', value: DifficultyLevel.Hard }];
        const LeaderboardDisplayComponent = () => {
          if (!leaderboard || leaderboard.length === 0) { return React.createElement('div', { className: "mt-6 pt-4 border-t border-slate-700 w-full max-w-md" }, React.createElement('h3', { className: "text-lg md:text-xl font-semibold text-sky-300 mb-3" }, "🏆 排行榜 🏆"), React.createElement('p', { className: "text-slate-400 text-sm" }, "排行榜暂无数据。成为第一个英雄！")); }
          return React.createElement('div', { className: "mt-6 pt-4 border-t border-slate-700 w-full max-w-md" }, React.createElement('h3', { className: "text-lg md:text-xl font-semibold text-sky-300 mb-3" }, "🏆 排行榜 (前 " + MAX_LEADERBOARD_ENTRIES + " 名) 🏆"),
            React.createElement('ol', { className: "list-none bg-slate-700/60 p-3 md:p-4 rounded-lg space-y-1.5 max-h-48 md:max-h-60 overflow-y-auto text-sm md:text-base" }, leaderboard.map((entry, index) => React.createElement('li', { key: index, className: "text-slate-200 flex justify-between items-center py-1 px-2 rounded hover:bg-slate-600/50 transition-colors" }, React.createElement('span', { className: "flex items-center" }, React.createElement('span', { className: "mr-2 w-7 text-right text-slate-400 font-mono" }, `${index + 1}.`), React.createElement('span', { className: "truncate max-w-[120px] sm:max-w-[150px] md:max-w-[200px]" }, entry.name)), React.createElement('span', { className: "font-semibold text-amber-300" }, entry.score))))
          );
        };
        if (status === GameStatus.Idle) { title = '标书拯救者'; content = React.createElement(React.Fragment, null, React.createElement('p', { className: "text-lg md:text-xl mb-8 text-slate-200 max-w-md mx-auto" }, "帮助标书员在老板发现前完成标书！点击蚊子消灭它们，小心突然出现的老板！"), React.createElement('button', { onClick: onReturnToSetup, className: "px-8 py-3 bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 text-white font-semibold rounded-lg shadow-xl text-xl transform transition-transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-cyan-300" }, "开始游戏"), React.createElement(LeaderboardDisplayComponent, null), React.createElement('div', { className: "mt-10 pt-6 border-t border-slate-700 px-2 max-w-xl mx-auto" }, React.createElement('p', { className: "text-base font-semibold animate-dynamic-text-gradient mb-2" }, "开发者：蟹老板"), React.createElement('p', { className: "text-sm animate-dynamic-text-gradient mb-1" }, "QQ: 625383053"), React.createElement('p', { className: "text-sm animate-dynamic-text-gradient" }, "微信群：{国网南网投标报价技术交流1群, 国网南网投标报价技术交流2群} 已满。"), React.createElement('p', { className: "text-sm animate-dynamic-text-gradient mt-1" }, "国网南网投标报价技术交流3群 期待您的加入！"), React.createElement('p', { className: "text-sm font-medium animate-dynamic-text-gradient mt-2" }, "入群请加微信：15979573075 (备注：投标交流)")));
        } else if (status === GameStatus.Setup) { title = '游戏设置'; content = React.createElement('div', { className: "w-full max-w-sm" }, React.createElement('div', { className: "mb-6" }, React.createElement('label', { htmlFor: "playerName", className: "block text-slate-200 text-lg mb-2" }, "你的名字:"), React.createElement('input', { type: "text", id: "playerName", value: localName, onChange: (e) => setLocalName(e.target.value), placeholder: "标书小能手", className: "w-full px-4 py-2 rounded-lg bg-slate-700 text-white border border-slate-500 focus:ring-2 focus:ring-sky-500 focus:border-sky-500 outline-none" })), React.createElement('div', { className: "mb-8" }, React.createElement('p', { className: "block text-slate-200 text-lg mb-3" }, "选择难度:"), React.createElement('div', { className: "flex justify-center space-x-3" }, difficultyOptions.map(opt => React.createElement('button', { key: opt.value, onClick: () => setLocalDifficulty(opt.value), className: `px-4 py-2 rounded-lg font-medium transition-all ${localDifficulty === opt.value ? 'bg-sky-500 text-white ring-2 ring-sky-300 shadow-lg' : 'bg-slate-600 text-slate-300 hover:bg-slate-500'}`}, opt.label)))), React.createElement('button', { onClick: () => onSubmitSetup(localName, localDifficulty), className: "w-full px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-semibold rounded-lg shadow-xl text-xl transform transition-transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-emerald-300" }, "开始挑战!"));
        } else if (status === GameStatus.Won || status === GameStatus.Lost) { title = status === GameStatus.Won ? '恭喜!' : '任务失败!'; const message = status === GameStatus.Won ? `在规定时间内完成标书！你太棒了！最终得分: ${score}` : `你完蛋了，未在规定时间内完成标书，标书递交失败，老板正在赶往你的办公室！最终得分: ${score}`; content = React.createElement(React.Fragment, null, React.createElement('p', { className: "text-lg md:text-xl mb-8 text-slate-200 max-w-md mx-auto" }, message), React.createElement('button', { onClick: onReturnToSetup, className: "px-8 py-3 bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 text-white font-semibold rounded-lg shadow-xl text-xl transform transition-transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-cyan-300" }, "再玩一次"), React.createElement(LeaderboardDisplayComponent, null)); }
        return React.createElement('div', { className: "absolute inset-0 bg-black/80 backdrop-blur-lg flex flex-col items-center justify-center z-50 p-4 sm:p-6 md:p-8 text-center overflow-y-auto" }, React.createElement('h1', { className: "text-3xl sm:text-4xl md:text-5xl font-bold mb-4 sm:mb-6 text-sky-400 drop-shadow-lg" }, title), content);
      };


      const App = () => {
        const [gameStatus, setGameStatus] = useState(GameStatus.Idle);
        const [playerName, setPlayerName] = useState('标书员');
        const [difficulty, setDifficulty] = useState(DifficultyLevel.Normal);
        const [progress, setProgress] = useState(0);
        const [timeLeft, setTimeLeft] = useState(null); 
        const [mosquitoes, setMosquitoes] = useState([]);
        const [score, setScore] = useState(0);
        const [isBittenCooldown, setIsBittenCooldown] = useState(0);
        const [mosquitoSpawnInterval, setMosquitoSpawnInterval] = useState(0); 
        const [boss, setBoss] = useState(null);
        const [leaderboard, setLeaderboard] = useState([]);
        const gameJustEndedRef = useRef(false); 
        const settings = DIFFICULTY_SETTINGS[difficulty]; 
        const TARGET_PROGRESS_PERCENT = 100;
        const WRITER_POSITION = { x: 50, y: 60 };
        const WRITER_HITBOX_RADIUS = 25; 
        const BITE_EFFECT_DURATION_MS = 2500;
        const [hasInteracted, setHasInteracted] = useState(false);

        // --- 音效 Refs ---
        const idleMusicRef = useRef(null); // 新增：用于 playgame.MP3
        const gameMusicRef = useRef(null); // 重命名：用于 background-music.MP3
        const typingSoundRef = useRef(null);
        const winSoundRef = useRef(null);
        const loseSoundRef = useRef(null);

        // --- 音效池 Refs (用于高频音效) ---
        const swatSoundPoolRef = useRef([]);
        const biteSoundPoolRef = useRef([]);
        const soundPoolSize = 5; 
        const currentSwatSoundIndexRef = useRef(0);
        const currentBiteSoundIndexRef = useRef(0);


        // --- 初始化音效 ---
        useEffect(() => {
            console.log("尝试初始化音频对象...");
            try {
                idleMusicRef.current = new Audio('sounds/playgame.MP3'); // 注意文件名大小写
                idleMusicRef.current.loop = true;
                idleMusicRef.current.oncanplaythrough = () => console.log("待机背景音乐 (playgame.MP3) 已准备好播放。");
                idleMusicRef.current.onerror = (e) => console.error("加载待机背景音乐失败:", e, idleMusicRef.current.error);

                gameMusicRef.current = new Audio('sounds/background-music.MP3');
                gameMusicRef.current.loop = true;
                gameMusicRef.current.oncanplaythrough = () => console.log("游戏背景音乐 (background-music.MP3) 已准备好播放。");
                gameMusicRef.current.onerror = (e) => console.error("加载游戏背景音乐失败:", e, gameMusicRef.current.error);

                typingSoundRef.current = new Audio('sounds/keyboard-typing.MP3');
                typingSoundRef.current.loop = true;
                typingSoundRef.current.oncanplaythrough = () => console.log("打字音效已准备好播放。");
                typingSoundRef.current.onerror = (e) => console.error("加载打字音效失败:", e, typingSoundRef.current.error);
                
                winSoundRef.current = new Audio('sounds/win-jingle.MP3');
                winSoundRef.current.oncanplaythrough = () => console.log("胜利音效已准备好播放。");
                winSoundRef.current.onerror = (e) => console.error("加载胜利音效失败:", e, winSoundRef.current.error);

                loseSoundRef.current = new Audio('sounds/lose-jingle.MP3');
                loseSoundRef.current.oncanplaythrough = () => console.log("失败音效已准备好播放。");
                loseSoundRef.current.onerror = (e) => console.error("加载失败音效失败:", e, loseSoundRef.current.error);

                swatSoundPoolRef.current = [];
                for (let i = 0; i < soundPoolSize; i++) {
                    const audio = new Audio('sounds/mosquito-swat.MP3');
                    audio.oncanplaythrough = () => console.log(`拍打音效实例 ${i} 已准备好播放。`);
                    audio.onerror = (e) => console.error(`加载拍打音效实例 ${i} 失败:`, e, audio.error);
                    swatSoundPoolRef.current.push(audio);
                }

                biteSoundPoolRef.current = [];
                 for (let i = 0; i < soundPoolSize; i++) {
                    const audio = new Audio('sounds/ouch-bite.MP3');
                    audio.oncanplaythrough = () => console.log(`被咬音效实例 ${i} 已准备好播放。`);
                    audio.onerror = (e) => console.error(`加载被咬音效实例 ${i} 失败:`, e, audio.error);
                    biteSoundPoolRef.current.push(audio);
                }
                console.log("音频对象初始化流程结束。");
            } catch (e) {
                console.error("初始化音频对象时发生严重错误:", e);
            }
            
            return () => { 
                console.log("清理音频对象。");
                idleMusicRef.current?.pause();
                gameMusicRef.current?.pause();
                typingSoundRef.current?.pause();
            };
        }, []);

        const playSoundFromPool = (poolRef, currentIndexRef) => {
            if (!hasInteracted || poolRef.current.length === 0) {
                if (!hasInteracted) console.warn("用户未交互，音效池音效不播放。");
                else console.warn("音效池为空，无法播放。");
                return;
            }
            const audio = poolRef.current[currentIndexRef.current];
            if (audio) {
                 if (audio.readyState >= 2) { 
                    audio.currentTime = 0;
                 }
                audio.play().catch(e => console.error("从池中播放音效失败:", e));
                currentIndexRef.current = (currentIndexRef.current + 1) % poolRef.current.length;
            } else {
                console.warn(`音效池索引 ${currentIndexRef.current} 无效。`);
            }
        };

        // --- 控制背景音乐 (Idle/Setup vs Playing) ---
        useEffect(() => {
            const playIdleMusic = () => {
                if (hasInteracted && idleMusicRef.current && idleMusicRef.current.paused) {
                    console.log("尝试播放待机背景音乐 (playgame.MP3)。");
                    gameMusicRef.current?.pause(); // 确保游戏音乐已暂停
                    idleMusicRef.current.play()
                        .then(() => console.log("待机背景音乐正在播放。"))
                        .catch(e => console.error("播放待机背景音乐失败:", e));
                }
            };

            const playGameMusic = () => {
                if (hasInteracted && gameMusicRef.current && gameMusicRef.current.paused) {
                    console.log("尝试播放游戏背景音乐 (background-music.MP3)。");
                    idleMusicRef.current?.pause(); // 确保待机音乐已暂停
                    gameMusicRef.current.play()
                        .then(() => console.log("游戏背景音乐正在播放。"))
                        .catch(e => console.error("播放游戏背景音乐失败:", e));
                }
            };
            
            const stopAllBackgroundMusic = () => {
                 console.log("停止所有背景音乐。");
                 idleMusicRef.current?.pause();
                 if (idleMusicRef.current?.readyState > 0) idleMusicRef.current.currentTime = 0;
                 gameMusicRef.current?.pause();
                 if (gameMusicRef.current?.readyState > 0) gameMusicRef.current.currentTime = 0;
            };

            if (gameStatus === GameStatus.Playing) {
                playGameMusic();
            } else if (gameStatus === GameStatus.Idle || gameStatus === GameStatus.Setup) {
                playIdleMusic();
            } else { // Won or Lost
                stopAllBackgroundMusic();
            }
        }, [gameStatus, hasInteracted]);


        // --- 控制打字音效 ---
        const isCurrentlyTyping = gameStatus === GameStatus.Playing && progress < TARGET_PROGRESS_PERCENT && timeLeft > 0;
        useEffect(() => {
            if (hasInteracted && isCurrentlyTyping && typingSoundRef.current) {
                console.log("尝试播放打字音效。");
                typingSoundRef.current.play()
                    .then(() => console.log("打字音效正在播放。"))
                    .catch(e => console.error("播放打字音效失败:", e));
            } else if (typingSoundRef.current) {
                // console.log("暂停打字音效。"); // 这条日志太频繁，可以注释掉
                typingSoundRef.current.pause();
                 if (typingSoundRef.current.readyState > 0) {
                    typingSoundRef.current.currentTime = 0;
                 }
            }
        }, [isCurrentlyTyping, hasInteracted]);


        useEffect(() => { initializeLeaderboard().then(setLeaderboard); }, []);
        
        const markUserInteraction = () => {
            if (!hasInteracted) {
                console.log("首次用户交互已标记。");
                setHasInteracted(true);
                // 尝试“预热”所有循环和池化音效
                const soundsToWarmUp = [
                    idleMusicRef.current,
                    gameMusicRef.current,
                    typingSoundRef.current,
                    ...(swatSoundPoolRef.current || []),
                    ...(biteSoundPoolRef.current || [])
                ];
                soundsToWarmUp.forEach(sound => {
                    if (sound && sound.paused && sound.readyState < 2) { // 仅当暂停且未完全加载时
                         console.log(`预热音效: ${sound.src}`);
                         sound.play().then(() => sound.pause()).catch(e => console.warn(`预热音效 ${sound.src} 失败:`, e.name, e.message));
                    }
                });
            }
        };

        const handleSubmitSetup = useCallback((name, selectedDifficulty) => {
            markUserInteraction();
            setPlayerName(name || '标书员');
            setDifficulty(selectedDifficulty);
            setGameStatus(GameStatus.Playing);
        }, [hasInteracted]); // 添加 hasInteracted 作为依赖
        
        const handleReturnToSetup = useCallback(() => {
            markUserInteraction(); // 如果用户直接从 Idle 点 "开始游戏" 到 Setup
            setGameStatus(GameStatus.Setup);
        }, [hasInteracted]); // 添加 hasInteracted 作为依赖
        
        // (游戏逻辑的 useEffects 和 handlers 基本不变，除了在播放事件音效时检查 hasInteracted)
        useEffect(() => {
          if (gameStatus === GameStatus.Playing) {
            const currentSettings = DIFFICULTY_SETTINGS[difficulty];
            setProgress(0); setTimeLeft(currentSettings.initialTime); setMosquitoes([]);
            setScore(0); setIsBittenCooldown(0);
            setMosquitoSpawnInterval(currentSettings.mosquitoSpawnInitial); setBoss(null);
            gameJustEndedRef.current = true; 
            console.log("[GAME DEBUG] 游戏开始。设置:", currentSettings);
          }
        }, [gameStatus, difficulty]);

        useEffect(() => { 
          if (gameStatus !== GameStatus.Playing || timeLeft === null) return;
          if (timeLeft <= 0) { setGameStatus(GameStatus.Lost); return; }
          const timerId = setInterval(() => setTimeLeft(prev => (prev !== null ? prev - 1 : null)), 1000);
          return () => clearInterval(timerId);
        }, [gameStatus, timeLeft]);

        useEffect(() => { 
          if (gameStatus !== GameStatus.Playing || timeLeft === null || timeLeft <= 0) return; 
          if (progress >= TARGET_PROGRESS_PERCENT) { setGameStatus(GameStatus.Won); return; }
          const progressIntervalId = setInterval(() => {
            setProgress(prev => {
              if (prev >= TARGET_PROGRESS_PERCENT) return prev; 
              let currentRate = settings.baseProgress / 10; 
              if (Date.now() < isBittenCooldown) currentRate *= settings.biteSlowdown;
              if (boss && boss.isVisible && !boss.clickedAway && Date.now() > boss.scoldStartTime && Date.now() < boss.scoldEndTime) {
                currentRate *= settings.bossScoldFactor;
              }
              return Math.max(0, Math.min(TARGET_PROGRESS_PERCENT, prev + currentRate));
            });
          }, 100);
          return () => clearInterval(progressIntervalId);
        }, [gameStatus, progress, timeLeft, isBittenCooldown, boss, settings]);

        useEffect(() => { 
          if (gameStatus !== GameStatus.Playing || timeLeft === null || timeLeft <= 0) return;
          const spawnId = setInterval(() => {
            const screenWidth = window.innerWidth; const screenHeight = window.innerHeight;
            let startX, startY; const edge = Math.floor(Math.random() * 4); const spawnOffset = 30; 
            switch (edge) {
              case 0: startX = Math.random() * screenWidth; startY = -spawnOffset; break;
              case 1: startX = screenWidth + spawnOffset; startY = Math.random() * screenHeight; break;
              case 2: startX = Math.random() * screenWidth; startY = screenHeight + spawnOffset; break;
              default: startX = -spawnOffset; startY = Math.random() * screenHeight; break;
            }
            const isRed = Math.random() < settings.redMosquitoSpawnChance;
            setMosquitoes(prev => [...prev, { id: Date.now() + Math.random(), x: startX, y: startY, isSwatted: false, spawnTime: Date.now(), type: isRed ? 'red' : 'normal' }]);
            setMosquitoSpawnInterval(prevInterval => Math.max(settings.mosquitoSpawnMin, prevInterval - 50));
          }, mosquitoSpawnInterval);
          return () => clearInterval(spawnId);
        }, [gameStatus, mosquitoSpawnInterval, settings]);
        
        useEffect(() => {
          if (gameStatus !== GameStatus.Playing || timeLeft === null || timeLeft <= 0) {
            return;
          }
          const bossInterval = setInterval(() => {
            const currentBossState = boss; 
            const randomRoll = Math.random();
            if (!currentBossState) { 
              if (randomRoll < settings.bossSpawnChance) {
                const screenHeight = window.innerHeight; 
                const slideDirection = Math.random() < 0.5 ? 'left' : 'right';
                const newBossId = Date.now();
                const newBossData = { 
                  id: newBossId, 
                  x: 0, y: screenHeight * 0.25, 
                  isVisible: true, 
                  isScolding: false, 
                  scoldStartTime: Date.now() + settings.bossScoldStartDelay, 
                  scoldEndTime: Date.now() + settings.bossScoldStartDelay + settings.bossDuration, 
                  clickedAway: false, 
                  slideDirection: slideDirection 
                };
                setBoss(newBossData);
              }
            } else if (currentBossState && currentBossState.isVisible && !currentBossState.clickedAway && Date.now() > currentBossState.scoldEndTime) {
              setBoss(b => b && b.id === currentBossState.id ? { ...b, clickedAway: true, isVisible: false } : b);
              setTimeout(() => {
                setBoss(cb => (cb && cb.id === currentBossState.id && cb.clickedAway) ? null : cb); 
              }, 1000); 
            }
          }, 3000); 
          return () => { clearInterval(bossInterval); };
        }, [gameStatus, boss, settings, timeLeft]); 

        useEffect(() => {
          if (gameJustEndedRef.current) {
            if (gameStatus === GameStatus.Won) { 
              console.log("[排行榜] 游戏胜利! 添加分数到排行榜。");
              // 停止所有背景音乐和打字音效已在主背景音乐控制useEffect中处理
              typingSoundRef.current?.pause();
              if(typingSoundRef.current && typingSoundRef.current.readyState > 0) typingSoundRef.current.currentTime = 0;
              
              console.log("尝试播放胜利音效。");
              winSoundRef.current?.play().catch(e => console.error("播放胜利音效失败:", e));
              
              gameJustEndedRef.current = false; 
              const finalPlayerName = playerName || '匿名玩家';
              setLeaderboard(prevLeaderboard => {
                const updatedLeaderboard = addScoreToLeaderboardList(finalPlayerName, score, prevLeaderboard);
                saveLeaderboardToAPI(updatedLeaderboard);
                saveLeaderboardToLocalStorage(updatedLeaderboard); 
                return updatedLeaderboard;
              });
            } else if (gameStatus === GameStatus.Lost) {
              console.log("[排行榜] 游戏失败! 分数未添加到排行榜。");
              typingSoundRef.current?.pause();
              if(typingSoundRef.current && typingSoundRef.current.readyState > 0) typingSoundRef.current.currentTime = 0;

              console.log("尝试播放失败音效。");
              loseSoundRef.current?.play().catch(e => console.error("播放失败音效失败:", e));
              
              gameJustEndedRef.current = false; 
            }
          }
        }, [gameStatus, score, playerName]); 
        
        const handleMosquitoSwat = useCallback((id) => { 
          if (gameStatus !== GameStatus.Playing || !hasInteracted) return;
          console.log("处理蚊子拍打事件。");
          playSoundFromPool(swatSoundPoolRef, currentSwatSoundIndexRef);

          let scoreIncrement = 1; 
          const swattedMosquito = mosquitoes.find(m => m.id === id);
          
          if (swattedMosquito && swattedMosquito.type === 'red') {
            scoreIncrement = 2; 
          }

          setScore(s => s + scoreIncrement);
          setMosquitoes(prev => prev.map(m => (m.id === id ? { ...m, isSwatted: true } : m))); 
          setTimeout(() => setMosquitoes(prev => prev.filter(m => m.id !== id)), 300);
        }, [gameStatus, mosquitoes, hasInteracted]); 

        const handleMosquitoReachTarget = useCallback((reachedMosquito) => { 
          if (gameStatus !== GameStatus.Playing || !hasInteracted) return;
          console.log("处理蚊子到达目标事件。");
          playSoundFromPool(biteSoundPoolRef, currentBiteSoundIndexRef);

          setMosquitoes(prev => prev.filter(m => m.id !== reachedMosquito.id));
          setIsBittenCooldown(Date.now() + BITE_EFFECT_DURATION_MS);
          setScore(s => Math.max(0, s - settings.mosquitoBiteScorePenalty));
          if (reachedMosquito.type === 'red') { setProgress(p => Math.max(0, p - settings.redMosquitoProgressPenalty)); }
        }, [gameStatus, settings, BITE_EFFECT_DURATION_MS, hasInteracted]);

        const handleBossClick = useCallback((id) => { 
          if (gameStatus !== GameStatus.Playing) return;
          setBoss(b => b && b.id === id ? { ...b, clickedAway: true, isVisible: false, isScolding: false } : b); 
          setScore(s => s + 5); 
          setTimeout(() => {
            setBoss(b => (b && b.id === id && b.clickedAway) ? null : b);
          }, 1000);
        }, [gameStatus]);

        const writerActualPos = { x: window.innerWidth * (WRITER_POSITION.x / 100), y: window.innerHeight * (WRITER_POSITION.y / 100) };
        
        // 用于触发首次用户交互的全局点击监听器
        useEffect(() => {
            const handleFirstInteraction = () => {
                markUserInteraction();
                window.removeEventListener('click', handleFirstInteraction, true);
                window.removeEventListener('keydown', handleFirstInteraction, true);
            };

            if (!hasInteracted) {
                // 使用捕获阶段确保尽早捕获交互
                window.addEventListener('click', handleFirstInteraction, true);
                window.addEventListener('keydown', handleFirstInteraction, true);
            }

            return () => {
                window.removeEventListener('click', handleFirstInteraction, true);
                window.removeEventListener('keydown', handleFirstInteraction, true);
            };
        }, [hasInteracted]); // 依赖 hasInteracted

        return React.createElement('div', { className: "relative w-screen h-screen overflow-hidden bg-gradient-to-br from-slate-200 to-slate-400 select-none" },
          gameStatus === GameStatus.Playing && React.createElement(React.Fragment, null,
            React.createElement('div', { className: "absolute top-4 left-4 right-4 p-4 bg-slate-800/70 backdrop-blur-md rounded-lg shadow-xl z-30" },
              React.createElement('div', { className: "flex justify-between items-center text-lg md:text-xl" }, React.createElement(TimerDisplay, { timeLeft: timeLeft }), React.createElement('div', { className: "text-amber-300" }, `分数: ${score}`)),
              React.createElement(ProgressBar, { progress: progress })
            ),
            React.createElement(TenderWriter, { playerName: playerName, position: WRITER_POSITION, isBitten: Date.now() < isBittenCooldown, isTyping: isCurrentlyTyping }),
            mosquitoes.map(mosquito => React.createElement(MosquitoComponent, { key: mosquito.id, mosquito: mosquito, onSwat: handleMosquitoSwat, onReachTarget: handleMosquitoReachTarget, targetPosition: writerActualPos, targetRadius: WRITER_HITBOX_RADIUS, speed: mosquito.type === 'red' ? settings.mosquitoSpeed * settings.redMosquitoSpeedMultiplier : settings.mosquitoSpeed })),
            boss && React.createElement(BossComponent, { bossData: boss, onClick: handleBossClick, playerName: playerName })
          ),
          (gameStatus === GameStatus.Idle || gameStatus === GameStatus.Setup || gameStatus === GameStatus.Won || gameStatus === GameStatus.Lost) && 
            React.createElement(GameOverlay, { status: gameStatus, score: score, onSubmitSetup: handleSubmitSetup, onReturnToSetup: handleReturnToSetup, leaderboard: leaderboard })
        );
      };
      ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App, null));
    </script>
</body>
</html>
--- END OF FILE index.html ---