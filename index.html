<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ê†á‰π¶ÊãØÊïëËÄÖ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body, html, #root {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; 
      }

      @keyframes ping_slow_once {
        0%, 100% { transform: scale(1); opacity: 0; }
        10%, 80% { transform: scale(1.2); opacity: 1; }
      }
      .animate-ping_slow_once {
        animation: ping_slow_once 0.7s cubic-bezier(0, 0, 0.2, 1) forwards;
      }

      @keyframes typing-bob {
        0%, 100% { transform: translateY(0) translateX(-50%); }
        50% { transform: translateY(-2px) translateX(-50%); }
      }
      .animate-typing-bob {
        animation: typing-bob 1s infinite ease-in-out;
      }

      @keyframes shake {
        0%, 100% { transform: translateX(-50%) translateY(-50%) rotate(0deg); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) translateY(-50%) rotate(-2deg); }
        20%, 40%, 60%, 80% { transform: translateX(-50%) translateY(-50%) rotate(2deg); }
      }
      .animate-shake {
        animation: shake 0.3s linear;
      }

      @keyframes screen-pulse-effect {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 1; }
      }
      .animate-screen-pulse {
        animation: screen-pulse-effect 1.5s infinite cubic-bezier(0.4, 0, 0.6, 1);
      }

      @keyframes boss-enter-left {
        from { left: -150px; opacity: 0; } 
        to { left: 15%; opacity: 1; } 
      }
      .animate-boss-enter-left { animation: boss-enter-left 1s ease-out forwards; }

      @keyframes boss-enter-right {
        from { left: calc(100% + 150px); opacity: 0; }
        to { left: 85%; opacity: 1; } 
      }
      .animate-boss-enter-right { animation: boss-enter-right 1s ease-out forwards; }
      
      @keyframes boss-exit-left {
        from { left: 15%; opacity: 1; }
        to { left: -150px; opacity: 0; }
      }
      .animate-boss-exit-left { animation: boss-exit-left 1s ease-in forwards; }

      @keyframes boss-exit-right {
        from { left: 85%; opacity: 1; }
        to { left: calc(100% + 150px); opacity: 0; }
      }
      .animate-boss-exit-right { animation: boss-exit-right 1s ease-in forwards; }

      @keyframes boss-scold-shake {
        0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
        25% { transform: translate(-50%, -50%) rotate(-2deg); }
        75% { transform: translate(-50%, -50%) rotate(2deg); }
      }
      .animate-boss-scold-shake {
        animation: boss-scold-shake 0.3s linear infinite;
      }

      @keyframes speech-bubble-appear {
        from { opacity: 0; transform: translateY(10px) scale(0.9); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      .animate-speech-bubble-appear {
        animation: speech-bubble-appear 0.3s ease-out forwards;
      }

      @keyframes dynamic-text-gradient {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      .animate-dynamic-text-gradient {
        background-image: linear-gradient(to right, #10b981, #3b82f6, #f59e0b, #ec4899, #10b981);
        background-size: 300% auto;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: dynamic-text-gradient 8s linear infinite;
      }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.1.0",
    "react-dom/client": "https://esm.sh/react-dom@19.1.0/client",
    "react-dom/": "https://esm.sh/react-dom@^19.1.0/",
    "react/": "https://esm.sh/react@^19.1.0/"
  }
}
</script>
</head>
<body>
    <noscript>‰Ω†ÈúÄË¶ÅÂêØÁî® JavaScript Êù•ËøêË°åÊ≠§Â∫îÁî®„ÄÇ</noscript>
    <div id="root"></div>

    <script type="module">
      import React, { useState, useEffect, useCallback, memo, useRef } from 'react';
      import ReactDOM from 'react-dom/client';

      const GameStatus = { Idle: 'idle', Setup: 'setup', Playing: 'playing', Won: 'won', Lost: 'lost' };
      const DifficultyLevel = { Easy: 'easy', Normal: 'normal', Hard: 'hard' };

      const DIFFICULTY_SETTINGS = {
        [DifficultyLevel.Easy]: {
          initialTime: 180, baseProgress: 2.0, biteSlowdown: 0.7, mosquitoSpawnInitial: 2200,
          mosquitoSpawnMin: 1000, mosquitoSpeed: 1.2, bossSpawnChance: 0.08, bossScoldFactor: 0.8,
          bossDuration: 15000, bossScoldStartDelay: 2000, mosquitoBiteScorePenalty: 1,
          redMosquitoSpawnChance: 0.10, redMosquitoSpeedMultiplier: 1.3, redMosquitoProgressPenalty: 3,
        },
        [DifficultyLevel.Normal]: {
          initialTime: 120, baseProgress: 1.5, biteSlowdown: 0.5, mosquitoSpawnInitial: 1500,
          mosquitoSpawnMin: 600, mosquitoSpeed: 1.5, bossSpawnChance: 0.15, bossScoldFactor: 0.6,
          bossDuration: 12000, bossScoldStartDelay: 1500, mosquitoBiteScorePenalty: 2,
          redMosquitoSpawnChance: 0.15, redMosquitoSpeedMultiplier: 1.5, redMosquitoProgressPenalty: 5,
        },
        [DifficultyLevel.Hard]: {
          initialTime: 90, baseProgress: 1.2, biteSlowdown: 0.3, mosquitoSpawnInitial: 1000,
          mosquitoSpawnMin: 400, mosquitoSpeed: 1.8, bossSpawnChance: 0.25, bossScoldFactor: 0.4,
          bossDuration: 10000, bossScoldStartDelay: 1000, mosquitoBiteScorePenalty: 3,
          redMosquitoSpawnChance: 0.20, redMosquitoSpeedMultiplier: 1.7, redMosquitoProgressPenalty: 7,
        },
      };

      const JSONBIN_API_URL_BASE = 'https://api.jsonbin.io/v3/b';
      const JSONBIN_BIN_ID = '6842b3b78561e97a5020422f'; 
      const JSONBIN_MASTER_KEY = '$2a$10$Qx80rURsF9e4Z0JPbTBsdu3bZv.0.j/8J3qFPiU0Lu.n0MhyKlQGi'; 
      const LEADERBOARD_API_READ_URL = `${JSONBIN_API_URL_BASE}/${JSONBIN_BIN_ID}/latest`;
      const LEADERBOARD_API_WRITE_URL = `${JSONBIN_API_URL_BASE}/${JSONBIN_BIN_ID}`;
      const LEADERBOARD_KEY_LOCAL_FALLBACK = 'tenderRescuerLeaderboard_local_v2'; 
      const MAX_LEADERBOARD_ENTRIES = 30;

      // (Leaderboard functions remain the same)
      async function loadLeaderboardFromAPI() {
        if (JSONBIN_BIN_ID === 'YOUR_BIN_ID_HERE' || JSONBIN_MASTER_KEY === 'YOUR_MASTER_KEY_HERE') { 
          console.warn("JSONBin API not configured. Skipping API load for leaderboard.");
          return null;
        }
        try {
          const response = await fetch(LEADERBOARD_API_READ_URL, {
            method: 'GET',
            headers: { 'X-Master-Key': JSONBIN_MASTER_KEY },
          });
          if (response.status === 404) { 
            console.log("Leaderboard bin not found on API, likely first run. Returning empty.");
            return []; 
          }
          if (!response.ok) {
            console.error(`Failed to load leaderboard from API: ${response.status} ${response.statusText}`);
            const errorBody = await response.text(); 
            console.error("Error body:", errorBody);
            return null;
          }
          const data = await response.json();
          const leaderboardData = data.record || data; 
          if (Array.isArray(leaderboardData) && leaderboardData.every(item => typeof item === 'object' && item !== null && 'name' in item && typeof item.name === 'string' && 'score' in item && typeof item.score === 'number')) {
            return leaderboardData;
          }
          console.warn("Loaded data from API is not in the expected format:", leaderboardData);
          return []; 
        } catch (error) {
          console.error("Error loading leaderboard from API:", error);
          return null;
        }
      }
      function loadLeaderboardFromLocalStorage() {
        try {
          const data = localStorage.getItem(LEADERBOARD_KEY_LOCAL_FALLBACK);
          if (data) {
            const parsedData = JSON.parse(data);
            if (Array.isArray(parsedData) && parsedData.every(item => typeof item === 'object' && item !== null && 'name' in item && typeof item.name === 'string' && 'score' in item && typeof item.score === 'number')) {
              return parsedData;
            }
          }
        } catch (error) {
          console.error("Failed to load leaderboard from localStorage:", error);
        }
        return [];
      }
      async function saveLeaderboardToAPI(leaderboard) {
        if (JSONBIN_BIN_ID === 'YOUR_BIN_ID_HERE' || JSONBIN_MASTER_KEY === 'YOUR_MASTER_KEY_HERE') { 
          console.warn("JSONBin API not configured. Skipping API save for leaderboard.");
          return false;
        }
        try {
          const response = await fetch(LEADERBOARD_API_WRITE_URL, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_MASTER_KEY, },
            body: JSON.stringify(leaderboard),
          });
          if (!response.ok) { 
              console.error(`Failed to save leaderboard to API: ${response.status} ${response.statusText}`);
              const errorBody = await response.text(); 
              console.error("Error body:", errorBody);
              return false; 
          }
          console.log("Leaderboard saved to API successfully.");
          return true;
        } catch (error) { console.error("Error saving leaderboard to API:", error); return false; }
      }
      function saveLeaderboardToLocalStorage(leaderboard) {
        try { localStorage.setItem(LEADERBOARD_KEY_LOCAL_FALLBACK, JSON.stringify(leaderboard)); }
        catch (error) { console.error("Failed to save leaderboard to localStorage:", error); }
      }
      async function initializeLeaderboard() {
        let apiLeaderboard = await loadLeaderboardFromAPI();
        if (apiLeaderboard !== null) { saveLeaderboardToLocalStorage(apiLeaderboard); return apiLeaderboard; }
        console.log("Falling back to localStorage for leaderboard.");
        return loadLeaderboardFromLocalStorage();
      }
      const addScoreToLeaderboardList = (name, score, currentLeaderboard) => {
        const newLeaderboard = [...currentLeaderboard, { name: name || "ÂåøÂêçÁé©ÂÆ∂", score }];
        newLeaderboard.sort((a, b) => b.score - a.score);
        return newLeaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
      };

      const SCOLD_MESSAGES = [
        (name) => `${name}, ËøôÊ†á‰π¶Âï•Êó∂ÂÄôËÉΩÂ•ΩÔºüÊäìÁ¥ßÁÇπÔºÅ`,
        (name) => `ÊàëÁúã‰Ω†ËøôËøõÂ∫¶Êù°ÔºåÊòØ‰∏çÊòØÂèàÊë∏È±º‰∫ÜÔºå${name}Ôºü`,
        (name) => `ÂÆ¢Êà∑Á≠âÁùÄÂë¢Ôºå${name}ÔºåÈÄüÂ∫¶ÔºÅ`,
        (name) => `ËøòÊúâÊó∂Èó¥ÂèëÂëÜÔºü${name}Ôºå‰∏çÊÉ≥Âπ≤‰∫ÜÔºü`,
        (name) => `ËøôË¥®Èáè‰∏çË°åÂïäÔºå${name}ÔºåËøîÂ∑•ÔºÅ...ÂºÄÁé©Á¨ëÁöÑÔºåÂø´ÁÇπÂ∞±Ë°å„ÄÇ`,
        (name) => `${name}Ôºå‰Ω†ÊÄé‰πàÂÜôÁöÑËøô‰πàÊÖ¢Ôºå‰Ω†ÊòØÁå™ÂêóÔºüÊïàÁéáÔºÅ`,
        (name) => `ÂñÇÔºå${name}ÔºÅËøôËøõÂ∫¶ÊòØËÆ§ÁúüÁöÑÂêóÔºüËöÇËöÅÊê¨ÂÆ∂ÈÉΩÊØî‰Ω†Âø´ÔºÅ`,
        (name) => `ÊàëËØ¥${name}ÔºåËøôÈÉΩÂá†ÁÇπ‰∫ÜÔºüÊ†á‰π¶ËøòÂú®ËøôÁ£®Ëπ≠Ôºü`,
        (name) => `${name}ÔºådeadlineÈÉΩË¶ÅÂà∞‰∫ÜÔºå‰Ω†ËøôÈîÆÁõòÈïøËòëËèá‰∫ÜÂêóÔºü`,
        (name) => `ÊàëÁúã‰Ω†‰∏çÊòØÂú®ÂÜôÊ†á‰π¶Ôºå${name}Ôºå‰Ω†ÊòØÂú®Áª£Ëä±ÂêßÔºüÂø´ÁÇπÔºÅ`,
        (name) => `ÊêûÂø´ÁÇπÔºå${name}ÔºÅÂÜçÊÖ¢‰∏ãÂéªÔºåÈªÑËä±ËèúÈÉΩÂáâ‰∫ÜÔºÅ`,
        (name) => `${name}ÔºåËøô‰ªΩÊ†á‰π¶ÊòØÁªô‰∏ã‰∏™‰∏ñÁ∫™ÁöÑÂÆ¢Êà∑ÂáÜÂ§áÁöÑÂêóÔºü`,
        (name) => `ÊâìËµ∑Á≤æÁ•ûÊù•Ôºå${name}ÔºÅËøôËøõÂ∫¶Êù°ÁúãÂæóÊàëË°ÄÂéãÈÉΩÈ´ò‰∫ÜÔºÅ`,
        (name) => `ËÉΩ‰∏çËÉΩË°åÂïäÔºå${name}Ôºü‰∏çË°åÊàëÊç¢‰∫∫‰∫ÜÂïäÔºÅÔºàÊãçÊ°åÔºâ`,
        (name) => `${name}ÔºåÁªô‰Ω†Ê≥°ÁöÑÂíñÂï°ÈÉΩÂÜ∑‰∫ÜÔºåÊ†á‰π¶ËøòÊ≤°‰∏ÄÂçäÔºü`,
        (name) => `ÂÖ∂‰ªñ‰∫∫Ê†á‰π¶ÈÉΩÂÜô‰∏â‰ªΩ‰∫ÜÔºå${name}Ôºå‰Ω†Ëøô‰ªΩËøòÊ≤°ÊêûÂÆöÔºü`
      ];

      // (UI Components like TimerDisplay, ProgressBar, TenderWriter, MosquitoComponent, BossComponent, GameOverlay remain the same)
      const TimerDisplay = ({ timeLeft }) => { 
        if (timeLeft === null) { return React.createElement('div', { className: 'font-mono text-lg text-green-300' }, 'Ââ©‰ΩôÊó∂Èó¥: --:--'); }
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        const timeClass = `font-mono text-lg ${timeLeft <= 10 && timeLeft > 0 ? 'text-red-400 animate-pulse' : 'text-green-300'}`;
        return React.createElement('div', { className: timeClass }, `Ââ©‰ΩôÊó∂Èó¥: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);
      };
      const ProgressBar = ({ progress }) => { 
        const displayProgress = Math.max(0, Math.min(100, progress));
        return React.createElement('div', { className: "mt-3" },
          React.createElement('div', { className: "flex justify-between mb-1" }, React.createElement('span', { className: "text-sm font-medium text-sky-200" }, "Ê†á‰π¶ËøõÂ∫¶"), React.createElement('span', { className: "text-sm font-medium text-sky-200" }, `${Math.round(displayProgress)}%`)),
          React.createElement('div', { className: "w-full bg-slate-600 rounded-full h-4 md:h-5 shadow-inner" }, React.createElement('div', { className: "bg-gradient-to-r from-sky-500 to-cyan-400 h-4 md:h-5 rounded-full transition-all duration-150 ease-linear", style: { width: `${displayProgress}%` }}))
        );
      };
      const TenderWriter = ({ playerName, position, isBitten, isTyping }) => { 
        const writerBaseClasses = "absolute transform -translate-x-1/2 -translate-y-1/2 p-2 transition-all duration-200";
        const writerAnimationClasses = `${isTyping ? 'animate-typing-bob' : ''} ${isBitten ? 'animate-shake' : ''}`;
        const typingText = isTyping ? `${playerName} Êí∞ÂÜô‰∏≠...` : 'Â∑≤ÂÆåÊàê!';
        return React.createElement('div', { className: `${writerBaseClasses} ${writerAnimationClasses}`, style: { left: `${position.x}%`, top: `${position.y}%`, zIndex: 20 }},
          React.createElement('div', { className: "bg-slate-200/70 p-3 rounded-lg shadow-lg w-28 h-36 md:w-32 md:h-40 relative backdrop-blur-sm" },
            React.createElement('div', { className: `absolute top-2 left-1/2 -translate-x-1/2 w-10 h-10 md:w-12 md:h-12 bg-pink-300 rounded-full border-2 border-slate-700` }),
            React.createElement('div', { className: `absolute top-10 left-1/2 -translate-x-1/2 w-16 h-20 md:w-20 md:h-24 bg-blue-500 rounded-md border-2 border-slate-700` }),
            React.createElement('div', { className: "absolute bottom-[-15px] left-1/2 -translate-x-1/2 w-36 h-10 md:w-40 bg-yellow-700 rounded-t-md border-2 border-slate-800 shadow-md" }),
            React.createElement('div', { className: "absolute bottom-[10px] left-1/2 -translate-x-1/2 w-20 h-16 md:w-24 md:h-20 bg-slate-800 rounded-sm border-2 border-slate-500 flex items-center justify-center p-1" },
              React.createElement('div', { className: `w-full h-full bg-sky-200 ${isTyping ? 'animate-screen-pulse' : ''} text-xs text-slate-900 p-1 overflow-hidden flex items-center justify-center font-semibold` }, typingText )
            ),
            isBitten && React.createElement('div', { className: "absolute -top-6 left-1/2 -translate-x-1/2 bg-red-500 text-white text-xs px-2 py-1 rounded-full shadow-lg animate-ping_slow_once" }, "ÂìéÂìü!")
          )
        );
      };
      const MosquitoComponent = memo(({ mosquito, onSwat, onReachTarget, targetPosition, targetRadius, speed }) => { 
        const [currentPosition, setCurrentPosition] = useState({ x: mosquito.x, y: mosquito.y });
        const MOSQUITO_WIGGLE_FACTOR = 0.5; 
        useEffect(() => {
          if (mosquito.isSwatted) return; 
          const moveInterval = setInterval(() => {
            setCurrentPosition(prevPos => {
              const dx = targetPosition.x - prevPos.x;
              const dy = targetPosition.y - prevPos.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < targetRadius) { onReachTarget(mosquito); clearInterval(moveInterval); return prevPos; }
              const wiggleX = (Math.random() - 0.5) * MOSQUITO_WIGGLE_FACTOR * speed * 5;
              const wiggleY = (Math.random() - 0.5) * MOSQUITO_WIGGLE_FACTOR * speed * 5;
              const moveX = (dx / dist) * speed + wiggleX;
              const moveY = (dy / dist) * speed + wiggleY;
              let newX = prevPos.x + moveX; let newY = prevPos.y + moveY;
              const margin = 100; 
              newX = Math.max(-margin, Math.min(window.innerWidth + margin, newX));
              newY = Math.max(-margin, Math.min(window.innerHeight + margin, newY));
              return { x: newX, y: newY };
            });
          }, 30); 
          return () => clearInterval(moveInterval);
        }, [mosquito, onReachTarget, targetPosition.x, targetPosition.y, targetRadius, speed]); 

        const isRed = mosquito.type === 'red';
        const bodyFill = isRed ? "#C53030" : "#333"; const headFill = isRed ? "#A02020" : "#222";
        const wingFill = isRed ? "rgba(239, 68, 68, 0.4)" : "rgba(0,0,0,0.3)"; const legStroke = isRed ? "#7F1D1D" : "#111";
        const liveMosquitoContent = React.createElement('svg', { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", className: "w-full h-full" }, React.createElement('ellipse', { cx: "50", cy: "50", rx: "15", ry: "25", fill: bodyFill }), React.createElement('circle', { cx: "50", cy: "25", r: "10", fill: headFill }), React.createElement('ellipse', { cx: "30", cy: "45", rx: "25", ry: "10", transform: "rotate(-20 30 45)", fill: wingFill }), React.createElement('ellipse', { cx: "70", cy: "45", rx: "25", ry: "10", transform: "rotate(20 70 45)", fill: wingFill }), React.createElement('line', { x1: "40", y1: "60", x2: "20", y2: "70", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "40", y1: "70", x2: "20", y2: "85", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "60", y1: "60", x2: "80", y2: "70", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "60", y1: "70", x2: "80", y2: "85", stroke: legStroke, strokeWidth: "3" }), React.createElement('line', { x1: "50", y1: "15", x2: "50", y2: "0", stroke: legStroke, strokeWidth: "3" }));
        const swattedMosquitoContent = React.createElement('div', { className: "absolute inset-0 flex items-center justify-center" }, React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "rgba(200, 38, 38, 0.95)", className: "w-12 h-12" }, React.createElement('path', { d: "M15.901 8.086a.75.75 0 00-1.06-1.06L12 9.879l-2.84-2.853a.75.75 0 10-1.061 1.06L10.939 12l-2.853 2.84a.75.75 0 001.06 1.061L12 13.061l2.84 2.853a.75.75 0 101.061-1.06L13.061 12l2.84-2.854zM2.193 8.617a10.423 10.423 0 01-.159-1.281A10.453 10.453 0 011.51 4.82a1.51 1.51 0 012.036-1.15c.44.198.832.457 1.185.765C5.594 3.64 6.36 3.056 7.216 2.61c.492-.254 1.01-.437 1.548-.55A10.45 10.45 0 0112.001 2c1.565 0 3.076.344 4.438.97.506.21 1 .485 1.442.818.93.702 1.524 1.468 1.93 2.332.21.457.353.93.434 1.419a10.453 10.453 0 010 3.038 11.75 11.75 0 01-.434 1.42c-.406.863-.999 1.63-1.93 2.331a4.14 4.14 0 01-1.442.818A10.45 10.45 0 0112.001 22a10.45 10.45 0 01-3.237-.56c-.538-.113-1.056-.296-1.548-.55-.855-.446-1.622-1.03-2.483-1.826-.353-.308-.746-.567-1.185-.765a1.51 1.51 0 01-1.15-2.036c.11-.59.154-1.185.159-1.781a10.428 10.428 0 00-.159-1.281l-.001-.001z" }) ));
        return React.createElement('div', { className: "absolute w-14 h-14 transform -translate-x-1/2 -translate-y-1/2 cursor-pointer drop-shadow-lg", style: { left: `${currentPosition.x}px`, top: `${currentPosition.y}px`, zIndex: mosquito.isSwatted ? 15 : 25 }, onClick: () => { if (!mosquito.isSwatted) { onSwat(mosquito.id); } } }, !mosquito.isSwatted ? liveMosquitoContent : swattedMosquitoContent );
      });
      const BossComponent = ({ bossData, onClick, playerName }) => { 
          const [scoldMessage, setScoldMessage] = useState(''); const [_tick, setTick] = useState(0); 
          const wasPreviouslyScoldingRef = useRef(false); const initialEntryStylesAppliedRef = useRef(false); const prevBossIdRef = useRef(null);
          useEffect(() => { if (bossData && prevBossIdRef.current !== bossData.id) { initialEntryStylesAppliedRef.current = false; prevBossIdRef.current = bossData.id;}}, [bossData]);
          useEffect(() => {
            if (!bossData.isVisible || bossData.clickedAway) { initialEntryStylesAppliedRef.current = false; return; }
            const timerId = setInterval(() => { const now = Date.now(); const currentlyInScoldWindow = now >= bossData.scoldStartTime && now < bossData.scoldEndTime; if (currentlyInScoldWindow || (wasPreviouslyScoldingRef.current && !currentlyInScoldWindow) || (!wasPreviouslyScoldingRef.current && currentlyInScoldWindow)) { setTick(t => t + 1); } if (now >= bossData.scoldEndTime) clearInterval(timerId); }, 500); 
            return () => clearInterval(timerId);
          }, [bossData.isVisible, bossData.clickedAway, bossData.scoldStartTime, bossData.scoldEndTime]);
          const isScoldingPeriodActive = bossData.isVisible && !bossData.clickedAway && Date.now() >= bossData.scoldStartTime && Date.now() < bossData.scoldEndTime;
          useEffect(() => { wasPreviouslyScoldingRef.current = isScoldingPeriodActive; }, [isScoldingPeriodActive]);
          useEffect(() => {
            let messageChangeIntervalId;
            if (isScoldingPeriodActive) { const pickNewMessage = () => { const randomScoldFn = SCOLD_MESSAGES[Math.floor(Math.random() * SCOLD_MESSAGES.length)]; setScoldMessage(randomScoldFn(playerName)); }; if (scoldMessage === '' || !wasPreviouslyScoldingRef.current) pickNewMessage(); messageChangeIntervalId = setInterval(() => { if (Date.now() < bossData.scoldEndTime) pickNewMessage(); else clearInterval(messageChangeIntervalId); }, 4000);
            } else { setScoldMessage(''); } return () => { if (messageChangeIntervalId) clearInterval(messageChangeIntervalId); };
          }, [isScoldingPeriodActive, playerName, bossData.id, bossData.scoldEndTime]); 
          
          if (!bossData) return null;
          
          let determinedAnimationClass = '';
          const appSaysBossShouldBeVisible = bossData.isVisible && !bossData.clickedAway;

          if (bossData.clickedAway) { 
            determinedAnimationClass = bossData.slideDirection === 'left' ? 'animate-boss-exit-left' : 'animate-boss-exit-right';
            initialEntryStylesAppliedRef.current = false; 
          } else if (appSaysBossShouldBeVisible) { 
            determinedAnimationClass = bossData.slideDirection === 'left' ? 'animate-boss-enter-left' : 'animate-boss-enter-right';
          } else { 
            determinedAnimationClass = bossData.slideDirection === 'left' ? 'animate-boss-exit-left' : 'animate-boss-exit-right';
            initialEntryStylesAppliedRef.current = false; 
          }
          
          const style = { top: `${bossData.y}px`, zIndex: 35, transform: `translate(-50%, -50%) ${isScoldingPeriodActive ? 'rotate(1deg)' : ''}`};
          
          if (appSaysBossShouldBeVisible && determinedAnimationClass.includes('enter') && !initialEntryStylesAppliedRef.current) { 
            style.opacity = 0; 
            style.left = bossData.slideDirection === 'right' ? `calc(100% + 150px)` : `-150px`; 
            initialEntryStylesAppliedRef.current = true; 
          }

          return React.createElement('div', { className: `absolute w-32 h-48 md:w-36 md:h-52 transform cursor-pointer p-2 ${isScoldingPeriodActive ? 'animate-boss-scold-shake' : ''} ${determinedAnimationClass}`, style: style, onClick: () => onClick(bossData.id) },
            React.createElement('div', { className: "w-full h-full bg-slate-700 rounded-lg border-4 border-slate-800 shadow-2xl relative flex flex-col items-center p-2" },
              React.createElement('div', { className: "w-16 h-16 bg-orange-300 rounded-full border-2 border-slate-900 mt-1" }), React.createElement('div', { className: "w-4 h-10 bg-red-600 mt-1 rounded-sm transform skew-y-6 border border-black" }), 
              React.createElement('div', { className: "w-24 h-20 bg-slate-600 rounded-md mt-[-10px] border-2 border-slate-900" }), React.createElement('div', { className: "absolute -top-5 left-1/2 -translate-x-1/2 bg-black text-white px-3 py-1 text-sm rounded-full shadow-md" }, "ËÄÅÊùø"),
              isScoldingPeriodActive && scoldMessage && React.createElement('div', { className: "absolute -top-20 left-1/2 -translate-x-1/2 min-w-[120px] max-w-[220px] bg-white p-2 rounded-lg shadow-xl border-2 border-gray-400 animate-speech-bubble-appear z-10" },
                React.createElement('p', { className: "text-sm text-gray-800 font-semibold" }, scoldMessage), React.createElement('div', { className: "absolute bottom-[-10px] left-1/2 -translate-x-1/2 w-0 h-0 border-l-[10px] border-l-transparent border-r-[10px] border-r-transparent border-t-[10px] border-t-white" })
          )));
      };
      const GameOverlay = ({ status, score, onSubmitSetup, onReturnToSetup, leaderboard }) => { 
        const [localName, setLocalName] = useState(''); const [localDifficulty, setLocalDifficulty] = useState(DifficultyLevel.Normal);
        let title = ''; let content; const difficultyOptions = [{ label: 'ÁÆÄÂçï', value: DifficultyLevel.Easy }, { label: '‰∏ÄËà¨', value: DifficultyLevel.Normal }, { label: 'Âõ∞Èöæ', value: DifficultyLevel.Hard }];
        const LeaderboardDisplayComponent = () => {
          if (!leaderboard || leaderboard.length === 0) { return React.createElement('div', { className: "mt-6 pt-4 border-t border-slate-700 w-full max-w-md" }, React.createElement('h3', { className: "text-lg md:text-xl font-semibold text-sky-300 mb-3" }, "üèÜ ÊéíË°åÊ¶ú üèÜ"), React.createElement('p', { className: "text-slate-400 text-sm" }, "ÊéíË°åÊ¶úÊöÇÊó†Êï∞ÊçÆ„ÄÇÊàê‰∏∫Á¨¨‰∏Ä‰∏™Ëã±ÈõÑÔºÅ")); }
          return React.createElement('div', { className: "mt-6 pt-4 border-t border-slate-700 w-full max-w-md" }, React.createElement('h3', { className: "text-lg md:text-xl font-semibold text-sky-300 mb-3" }, "üèÜ ÊéíË°åÊ¶ú (Ââç " + MAX_LEADERBOARD_ENTRIES + " Âêç) üèÜ"),
            React.createElement('ol', { className: "list-none bg-slate-700/60 p-3 md:p-4 rounded-lg space-y-1.5 max-h-48 md:max-h-60 overflow-y-auto text-sm md:text-base" }, leaderboard.map((entry, index) => React.createElement('li', { key: index, className: "text-slate-200 flex justify-between items-center py-1 px-2 rounded hover:bg-slate-600/50 transition-colors" }, React.createElement('span', { className: "flex items-center" }, React.createElement('span', { className: "mr-2 w-7 text-right text-slate-400 font-mono" }, `${index + 1}.`), React.createElement('span', { className: "truncate max-w-[120px] sm:max-w-[150px] md:max-w-[200px]" }, entry.name)), React.createElement('span', { className: "font-semibold text-amber-300" }, entry.score))))
          );
        };
        if (status === GameStatus.Idle) { title = 'Ê†á‰π¶ÊãØÊïëËÄÖ'; content = React.createElement(React.Fragment, null, React.createElement('p', { className: "text-lg md:text-xl mb-8 text-slate-200 max-w-md mx-auto" }, "Â∏ÆÂä©Ê†á‰π¶ÂëòÂú®ËÄÅÊùøÂèëÁé∞ÂâçÂÆåÊàêÊ†á‰π¶ÔºÅÁÇπÂáªËöäÂ≠êÊ∂àÁÅ≠ÂÆÉ‰ª¨ÔºåÂ∞èÂøÉÁ™ÅÁÑ∂Âá∫Áé∞ÁöÑËÄÅÊùøÔºÅ"), React.createElement('button', { onClick: onReturnToSetup, className: "px-8 py-3 bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 text-white font-semibold rounded-lg shadow-xl text-xl transform transition-transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-cyan-300" }, "ÂºÄÂßãÊ∏∏Êàè"), React.createElement(LeaderboardDisplayComponent, null), React.createElement('div', { className: "mt-10 pt-6 border-t border-slate-700 px-2 max-w-xl mx-auto" }, React.createElement('p', { className: "text-base font-semibold animate-dynamic-text-gradient mb-2" }, "ÂºÄÂèëËÄÖÔºöËüπËÄÅÊùø"), React.createElement('p', { className: "text-sm animate-dynamic-text-gradient mb-1" }, "QQ: 625383053"), React.createElement('p', { className: "text-sm animate-dynamic-text-gradient" }, "ÂæÆ‰ø°Áæ§Ôºö{ÂõΩÁΩëÂçóÁΩëÊäïÊ†áÊä•‰ª∑ÊäÄÊúØ‰∫§ÊµÅ1Áæ§, ÂõΩÁΩëÂçóÁΩëÊäïÊ†áÊä•‰ª∑ÊäÄÊúØ‰∫§ÊµÅ2Áæ§} Â∑≤Êª°„ÄÇ"), React.createElement('p', { className: "text-sm animate-dynamic-text-gradient mt-1" }, "ÂõΩÁΩëÂçóÁΩëÊäïÊ†áÊä•‰ª∑ÊäÄÊúØ‰∫§ÊµÅ3Áæ§ ÊúüÂæÖÊÇ®ÁöÑÂä†ÂÖ•ÔºÅ"), React.createElement('p', { className: "text-sm font-medium animate-dynamic-text-gradient mt-2" }, "ÂÖ•Áæ§ËØ∑Âä†ÂæÆ‰ø°Ôºö15979573075 (Â§áÊ≥®ÔºöÊäïÊ†á‰∫§ÊµÅ)")));
        } else if (status === GameStatus.Setup) { title = 'Ê∏∏ÊàèËÆæÁΩÆ'; content = React.createElement('div', { className: "w-full max-w-sm" }, React.createElement('div', { className: "mb-6" }, React.createElement('label', { htmlFor: "playerName", className: "block text-slate-200 text-lg mb-2" }, "‰Ω†ÁöÑÂêçÂ≠ó:"), React.createElement('input', { type: "text", id: "playerName", value: localName, onChange: (e) => setLocalName(e.target.value), placeholder: "Ê†á‰π¶Â∞èËÉΩÊâã", className: "w-full px-4 py-2 rounded-lg bg-slate-700 text-white border border-slate-500 focus:ring-2 focus:ring-sky-500 focus:border-sky-500 outline-none" })), React.createElement('div', { className: "mb-8" }, React.createElement('p', { className: "block text-slate-200 text-lg mb-3" }, "ÈÄâÊã©ÈöæÂ∫¶:"), React.createElement('div', { className: "flex justify-center space-x-3" }, difficultyOptions.map(opt => React.createElement('button', { key: opt.value, onClick: () => setLocalDifficulty(opt.value), className: `px-4 py-2 rounded-lg font-medium transition-all ${localDifficulty === opt.value ? 'bg-sky-500 text-white ring-2 ring-sky-300 shadow-lg' : 'bg-slate-600 text-slate-300 hover:bg-slate-500'}`}, opt.label)))), React.createElement('button', { onClick: () => onSubmitSetup(localName, localDifficulty), className: "w-full px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-semibold rounded-lg shadow-xl text-xl transform transition-transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-emerald-300" }, "ÂºÄÂßãÊåëÊàò!"));
        } else if (status === GameStatus.Won || status === GameStatus.Lost) { title = status === GameStatus.Won ? 'ÊÅ≠Âñú!' : '‰ªªÂä°Â§±Ë¥•!'; const message = status === GameStatus.Won ? `Âú®ËßÑÂÆöÊó∂Èó¥ÂÜÖÂÆåÊàêÊ†á‰π¶ÔºÅ‰Ω†Â§™Ê£í‰∫ÜÔºÅÊúÄÁªàÂæóÂàÜ: ${score}` : `‰Ω†ÂÆåËõã‰∫ÜÔºåÊú™Âú®ËßÑÂÆöÊó∂Èó¥ÂÜÖÂÆåÊàêÊ†á‰π¶ÔºåÊ†á‰π¶ÈÄí‰∫§Â§±Ë¥•ÔºåËÄÅÊùøÊ≠£Âú®Ëµ∂ÂæÄ‰Ω†ÁöÑÂäûÂÖ¨ÂÆ§ÔºÅÊúÄÁªàÂæóÂàÜ: ${score}`; content = React.createElement(React.Fragment, null, React.createElement('p', { className: "text-lg md:text-xl mb-8 text-slate-200 max-w-md mx-auto" }, message), React.createElement('button', { onClick: onReturnToSetup, className: "px-8 py-3 bg-gradient-to-r from-teal-500 to-cyan-600 hover:from-teal-600 hover:to-cyan-700 text-white font-semibold rounded-lg shadow-xl text-xl transform transition-transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-cyan-300" }, "ÂÜçÁé©‰∏ÄÊ¨°"), React.createElement(LeaderboardDisplayComponent, null)); }
        return React.createElement('div', { className: "absolute inset-0 bg-black/80 backdrop-blur-lg flex flex-col items-center justify-center z-50 p-4 sm:p-6 md:p-8 text-center overflow-y-auto" }, React.createElement('h1', { className: "text-3xl sm:text-4xl md:text-5xl font-bold mb-4 sm:mb-6 text-sky-400 drop-shadow-lg" }, title), content);
      };


      const App = () => {
        const [gameStatus, setGameStatus] = useState(GameStatus.Idle);
        const [playerName, setPlayerName] = useState('Ê†á‰π¶Âëò');
        const [difficulty, setDifficulty] = useState(DifficultyLevel.Normal);
        const [progress, setProgress] = useState(0);
        const [timeLeft, setTimeLeft] = useState(null); 
        const [mosquitoes, setMosquitoes] = useState([]);
        const [score, setScore] = useState(0);
        const [isBittenCooldown, setIsBittenCooldown] = useState(0);
        const [mosquitoSpawnInterval, setMosquitoSpawnInterval] = useState(0); 
        const [boss, setBoss] = useState(null);
        const [leaderboard, setLeaderboard] = useState([]);
        const gameJustEndedRef = useRef(false); 
        const settings = DIFFICULTY_SETTINGS[difficulty]; 
        const TARGET_PROGRESS_PERCENT = 100;
        const WRITER_POSITION = { x: 50, y: 60 };
        const WRITER_HITBOX_RADIUS = 25; 
        const BITE_EFFECT_DURATION_MS = 2500;
        const [hasInteracted, setHasInteracted] = useState(false);

        // --- Èü≥Êïà Refs ---
        const idleMusicRef = useRef(null); // Êñ∞Â¢ûÔºöÁî®‰∫é playgame.MP3
        const gameMusicRef = useRef(null); // ÈáçÂëΩÂêçÔºöÁî®‰∫é background-music.MP3
        const typingSoundRef = useRef(null);
        const winSoundRef = useRef(null);
        const loseSoundRef = useRef(null);

        // --- Èü≥ÊïàÊ±† Refs (Áî®‰∫éÈ´òÈ¢ëÈü≥Êïà) ---
        const swatSoundPoolRef = useRef([]);
        const biteSoundPoolRef = useRef([]);
        const soundPoolSize = 5; 
        const currentSwatSoundIndexRef = useRef(0);
        const currentBiteSoundIndexRef = useRef(0);


        // --- ÂàùÂßãÂåñÈü≥Êïà ---
        useEffect(() => {
            console.log("Â∞ùËØïÂàùÂßãÂåñÈü≥È¢ëÂØπË±°...");
            try {
                idleMusicRef.current = new Audio('sounds/playgame.MP3'); // Ê≥®ÊÑèÊñá‰ª∂ÂêçÂ§ßÂ∞èÂÜô
                idleMusicRef.current.loop = true;
                idleMusicRef.current.oncanplaythrough = () => console.log("ÂæÖÊú∫ËÉåÊôØÈü≥‰πê (playgame.MP3) Â∑≤ÂáÜÂ§áÂ•ΩÊí≠Êîæ„ÄÇ");
                idleMusicRef.current.onerror = (e) => console.error("Âä†ËΩΩÂæÖÊú∫ËÉåÊôØÈü≥‰πêÂ§±Ë¥•:", e, idleMusicRef.current.error);

                gameMusicRef.current = new Audio('sounds/background-music.MP3');
                gameMusicRef.current.loop = true;
                gameMusicRef.current.oncanplaythrough = () => console.log("Ê∏∏ÊàèËÉåÊôØÈü≥‰πê (background-music.MP3) Â∑≤ÂáÜÂ§áÂ•ΩÊí≠Êîæ„ÄÇ");
                gameMusicRef.current.onerror = (e) => console.error("Âä†ËΩΩÊ∏∏ÊàèËÉåÊôØÈü≥‰πêÂ§±Ë¥•:", e, gameMusicRef.current.error);

                typingSoundRef.current = new Audio('sounds/keyboard-typing.MP3');
                typingSoundRef.current.loop = true;
                typingSoundRef.current.oncanplaythrough = () => console.log("ÊâìÂ≠óÈü≥ÊïàÂ∑≤ÂáÜÂ§áÂ•ΩÊí≠Êîæ„ÄÇ");
                typingSoundRef.current.onerror = (e) => console.error("Âä†ËΩΩÊâìÂ≠óÈü≥ÊïàÂ§±Ë¥•:", e, typingSoundRef.current.error);
                
                winSoundRef.current = new Audio('sounds/win-jingle.MP3');
                winSoundRef.current.oncanplaythrough = () => console.log("ËÉúÂà©Èü≥ÊïàÂ∑≤ÂáÜÂ§áÂ•ΩÊí≠Êîæ„ÄÇ");
                winSoundRef.current.onerror = (e) => console.error("Âä†ËΩΩËÉúÂà©Èü≥ÊïàÂ§±Ë¥•:", e, winSoundRef.current.error);

                loseSoundRef.current = new Audio('sounds/lose-jingle.MP3');
                loseSoundRef.current.oncanplaythrough = () => console.log("Â§±Ë¥•Èü≥ÊïàÂ∑≤ÂáÜÂ§áÂ•ΩÊí≠Êîæ„ÄÇ");
                loseSoundRef.current.onerror = (e) => console.error("Âä†ËΩΩÂ§±Ë¥•Èü≥ÊïàÂ§±Ë¥•:", e, loseSoundRef.current.error);

                swatSoundPoolRef.current = [];
                for (let i = 0; i < soundPoolSize; i++) {
                    const audio = new Audio('sounds/mosquito-swat.MP3');
                    audio.oncanplaythrough = () => console.log(`ÊãçÊâìÈü≥ÊïàÂÆû‰æã ${i} Â∑≤ÂáÜÂ§áÂ•ΩÊí≠Êîæ„ÄÇ`);
                    audio.onerror = (e) => console.error(`Âä†ËΩΩÊãçÊâìÈü≥ÊïàÂÆû‰æã ${i} Â§±Ë¥•:`, e, audio.error);
                    swatSoundPoolRef.current.push(audio);
                }

                biteSoundPoolRef.current = [];
                 for (let i = 0; i < soundPoolSize; i++) {
                    const audio = new Audio('sounds/ouch-bite.MP3');
                    audio.oncanplaythrough = () => console.log(`Ë¢´Âí¨Èü≥ÊïàÂÆû‰æã ${i} Â∑≤ÂáÜÂ§áÂ•ΩÊí≠Êîæ„ÄÇ`);
                    audio.onerror = (e) => console.error(`Âä†ËΩΩË¢´Âí¨Èü≥ÊïàÂÆû‰æã ${i} Â§±Ë¥•:`, e, audio.error);
                    biteSoundPoolRef.current.push(audio);
                }
                console.log("Èü≥È¢ëÂØπË±°ÂàùÂßãÂåñÊµÅÁ®ãÁªìÊùü„ÄÇ");
            } catch (e) {
                console.error("ÂàùÂßãÂåñÈü≥È¢ëÂØπË±°Êó∂ÂèëÁîü‰∏•ÈáçÈîôËØØ:", e);
            }
            
            return () => { 
                console.log("Ê∏ÖÁêÜÈü≥È¢ëÂØπË±°„ÄÇ");
                idleMusicRef.current?.pause();
                gameMusicRef.current?.pause();
                typingSoundRef.current?.pause();
            };
        }, []);

        const playSoundFromPool = (poolRef, currentIndexRef) => {
            if (!hasInteracted || poolRef.current.length === 0) {
                if (!hasInteracted) console.warn("Áî®Êà∑Êú™‰∫§‰∫íÔºåÈü≥ÊïàÊ±†Èü≥Êïà‰∏çÊí≠Êîæ„ÄÇ");
                else console.warn("Èü≥ÊïàÊ±†‰∏∫Á©∫ÔºåÊó†Ê≥ïÊí≠Êîæ„ÄÇ");
                return;
            }
            const audio = poolRef.current[currentIndexRef.current];
            if (audio) {
                 if (audio.readyState >= 2) { 
                    audio.currentTime = 0;
                 }
                audio.play().catch(e => console.error("‰ªéÊ±†‰∏≠Êí≠ÊîæÈü≥ÊïàÂ§±Ë¥•:", e));
                currentIndexRef.current = (currentIndexRef.current + 1) % poolRef.current.length;
            } else {
                console.warn(`Èü≥ÊïàÊ±†Á¥¢Âºï ${currentIndexRef.current} Êó†Êïà„ÄÇ`);
            }
        };

        // --- ÊéßÂà∂ËÉåÊôØÈü≥‰πê (Idle/Setup vs Playing) ---
        useEffect(() => {
            const playIdleMusic = () => {
                if (hasInteracted && idleMusicRef.current && idleMusicRef.current.paused) {
                    console.log("Â∞ùËØïÊí≠ÊîæÂæÖÊú∫ËÉåÊôØÈü≥‰πê (playgame.MP3)„ÄÇ");
                    gameMusicRef.current?.pause(); // Á°Æ‰øùÊ∏∏ÊàèÈü≥‰πêÂ∑≤ÊöÇÂÅú
                    idleMusicRef.current.play()
                        .then(() => console.log("ÂæÖÊú∫ËÉåÊôØÈü≥‰πêÊ≠£Âú®Êí≠Êîæ„ÄÇ"))
                        .catch(e => console.error("Êí≠ÊîæÂæÖÊú∫ËÉåÊôØÈü≥‰πêÂ§±Ë¥•:", e));
                }
            };

            const playGameMusic = () => {
                if (hasInteracted && gameMusicRef.current && gameMusicRef.current.paused) {
                    console.log("Â∞ùËØïÊí≠ÊîæÊ∏∏ÊàèËÉåÊôØÈü≥‰πê (background-music.MP3)„ÄÇ");
                    idleMusicRef.current?.pause(); // Á°Æ‰øùÂæÖÊú∫Èü≥‰πêÂ∑≤ÊöÇÂÅú
                    gameMusicRef.current.play()
                        .then(() => console.log("Ê∏∏ÊàèËÉåÊôØÈü≥‰πêÊ≠£Âú®Êí≠Êîæ„ÄÇ"))
                        .catch(e => console.error("Êí≠ÊîæÊ∏∏ÊàèËÉåÊôØÈü≥‰πêÂ§±Ë¥•:", e));
                }
            };
            
            const stopAllBackgroundMusic = () => {
                 console.log("ÂÅúÊ≠¢ÊâÄÊúâËÉåÊôØÈü≥‰πê„ÄÇ");
                 idleMusicRef.current?.pause();
                 if (idleMusicRef.current?.readyState > 0) idleMusicRef.current.currentTime = 0;
                 gameMusicRef.current?.pause();
                 if (gameMusicRef.current?.readyState > 0) gameMusicRef.current.currentTime = 0;
            };

            if (gameStatus === GameStatus.Playing) {
                playGameMusic();
            } else if (gameStatus === GameStatus.Idle || gameStatus === GameStatus.Setup) {
                playIdleMusic();
            } else { // Won or Lost
                stopAllBackgroundMusic();
            }
        }, [gameStatus, hasInteracted]);


        // --- ÊéßÂà∂ÊâìÂ≠óÈü≥Êïà ---
        const isCurrentlyTyping = gameStatus === GameStatus.Playing && progress < TARGET_PROGRESS_PERCENT && timeLeft > 0;
        useEffect(() => {
            if (hasInteracted && isCurrentlyTyping && typingSoundRef.current) {
                console.log("Â∞ùËØïÊí≠ÊîæÊâìÂ≠óÈü≥Êïà„ÄÇ");
                typingSoundRef.current.play()
                    .then(() => console.log("ÊâìÂ≠óÈü≥ÊïàÊ≠£Âú®Êí≠Êîæ„ÄÇ"))
                    .catch(e => console.error("Êí≠ÊîæÊâìÂ≠óÈü≥ÊïàÂ§±Ë¥•:", e));
            } else if (typingSoundRef.current) {
                // console.log("ÊöÇÂÅúÊâìÂ≠óÈü≥Êïà„ÄÇ"); // ËøôÊù°Êó•ÂøóÂ§™È¢ëÁπÅÔºåÂèØ‰ª•Ê≥®ÈáäÊéâ
                typingSoundRef.current.pause();
                 if (typingSoundRef.current.readyState > 0) {
                    typingSoundRef.current.currentTime = 0;
                 }
            }
        }, [isCurrentlyTyping, hasInteracted]);


        useEffect(() => { initializeLeaderboard().then(setLeaderboard); }, []);
        
        const markUserInteraction = () => {
            if (!hasInteracted) {
                console.log("È¶ñÊ¨°Áî®Êà∑‰∫§‰∫íÂ∑≤Ê†áËÆ∞„ÄÇ");
                setHasInteracted(true);
                // Â∞ùËØï‚ÄúÈ¢ÑÁÉ≠‚ÄùÊâÄÊúâÂæ™ÁéØÂíåÊ±†ÂåñÈü≥Êïà
                const soundsToWarmUp = [
                    idleMusicRef.current,
                    gameMusicRef.current,
                    typingSoundRef.current,
                    ...(swatSoundPoolRef.current || []),
                    ...(biteSoundPoolRef.current || [])
                ];
                soundsToWarmUp.forEach(sound => {
                    if (sound && sound.paused && sound.readyState < 2) { // ‰ªÖÂΩìÊöÇÂÅú‰∏îÊú™ÂÆåÂÖ®Âä†ËΩΩÊó∂
                         console.log(`È¢ÑÁÉ≠Èü≥Êïà: ${sound.src}`);
                         sound.play().then(() => sound.pause()).catch(e => console.warn(`È¢ÑÁÉ≠Èü≥Êïà ${sound.src} Â§±Ë¥•:`, e.name, e.message));
                    }
                });
            }
        };

        const handleSubmitSetup = useCallback((name, selectedDifficulty) => {
            markUserInteraction();
            setPlayerName(name || 'Ê†á‰π¶Âëò');
            setDifficulty(selectedDifficulty);
            setGameStatus(GameStatus.Playing);
        }, [hasInteracted]); // Ê∑ªÂä† hasInteracted ‰Ωú‰∏∫‰æùËµñ
        
        const handleReturnToSetup = useCallback(() => {
            markUserInteraction(); // Â¶ÇÊûúÁî®Êà∑Áõ¥Êé•‰ªé Idle ÁÇπ "ÂºÄÂßãÊ∏∏Êàè" Âà∞ Setup
            setGameStatus(GameStatus.Setup);
        }, [hasInteracted]); // Ê∑ªÂä† hasInteracted ‰Ωú‰∏∫‰æùËµñ
        
        // (Ê∏∏ÊàèÈÄªËæëÁöÑ useEffects Âíå handlers Âü∫Êú¨‰∏çÂèòÔºåÈô§‰∫ÜÂú®Êí≠Êîæ‰∫ã‰ª∂Èü≥ÊïàÊó∂Ê£ÄÊü• hasInteracted)
        useEffect(() => {
          if (gameStatus === GameStatus.Playing) {
            const currentSettings = DIFFICULTY_SETTINGS[difficulty];
            setProgress(0); setTimeLeft(currentSettings.initialTime); setMosquitoes([]);
            setScore(0); setIsBittenCooldown(0);
            setMosquitoSpawnInterval(currentSettings.mosquitoSpawnInitial); setBoss(null);
            gameJustEndedRef.current = true; 
            console.log("[GAME DEBUG] Ê∏∏ÊàèÂºÄÂßã„ÄÇËÆæÁΩÆ:", currentSettings);
          }
        }, [gameStatus, difficulty]);

        useEffect(() => { 
          if (gameStatus !== GameStatus.Playing || timeLeft === null) return;
          if (timeLeft <= 0) { setGameStatus(GameStatus.Lost); return; }
          const timerId = setInterval(() => setTimeLeft(prev => (prev !== null ? prev - 1 : null)), 1000);
          return () => clearInterval(timerId);
        }, [gameStatus, timeLeft]);

        useEffect(() => { 
          if (gameStatus !== GameStatus.Playing || timeLeft === null || timeLeft <= 0) return; 
          if (progress >= TARGET_PROGRESS_PERCENT) { setGameStatus(GameStatus.Won); return; }
          const progressIntervalId = setInterval(() => {
            setProgress(prev => {
              if (prev >= TARGET_PROGRESS_PERCENT) return prev; 
              let currentRate = settings.baseProgress / 10; 
              if (Date.now() < isBittenCooldown) currentRate *= settings.biteSlowdown;
              if (boss && boss.isVisible && !boss.clickedAway && Date.now() > boss.scoldStartTime && Date.now() < boss.scoldEndTime) {
                currentRate *= settings.bossScoldFactor;
              }
              return Math.max(0, Math.min(TARGET_PROGRESS_PERCENT, prev + currentRate));
            });
          }, 100);
          return () => clearInterval(progressIntervalId);
        }, [gameStatus, progress, timeLeft, isBittenCooldown, boss, settings]);

        useEffect(() => { 
          if (gameStatus !== GameStatus.Playing || timeLeft === null || timeLeft <= 0) return;
          const spawnId = setInterval(() => {
            const screenWidth = window.innerWidth; const screenHeight = window.innerHeight;
            let startX, startY; const edge = Math.floor(Math.random() * 4); const spawnOffset = 30; 
            switch (edge) {
              case 0: startX = Math.random() * screenWidth; startY = -spawnOffset; break;
              case 1: startX = screenWidth + spawnOffset; startY = Math.random() * screenHeight; break;
              case 2: startX = Math.random() * screenWidth; startY = screenHeight + spawnOffset; break;
              default: startX = -spawnOffset; startY = Math.random() * screenHeight; break;
            }
            const isRed = Math.random() < settings.redMosquitoSpawnChance;
            setMosquitoes(prev => [...prev, { id: Date.now() + Math.random(), x: startX, y: startY, isSwatted: false, spawnTime: Date.now(), type: isRed ? 'red' : 'normal' }]);
            setMosquitoSpawnInterval(prevInterval => Math.max(settings.mosquitoSpawnMin, prevInterval - 50));
          }, mosquitoSpawnInterval);
          return () => clearInterval(spawnId);
        }, [gameStatus, mosquitoSpawnInterval, settings]);
        
        useEffect(() => {
          if (gameStatus !== GameStatus.Playing || timeLeft === null || timeLeft <= 0) {
            return;
          }
          const bossInterval = setInterval(() => {
            const currentBossState = boss; 
            const randomRoll = Math.random();
            if (!currentBossState) { 
              if (randomRoll < settings.bossSpawnChance) {
                const screenHeight = window.innerHeight; 
                const slideDirection = Math.random() < 0.5 ? 'left' : 'right';
                const newBossId = Date.now();
                const newBossData = { 
                  id: newBossId, 
                  x: 0, y: screenHeight * 0.25, 
                  isVisible: true, 
                  isScolding: false, 
                  scoldStartTime: Date.now() + settings.bossScoldStartDelay, 
                  scoldEndTime: Date.now() + settings.bossScoldStartDelay + settings.bossDuration, 
                  clickedAway: false, 
                  slideDirection: slideDirection 
                };
                setBoss(newBossData);
              }
            } else if (currentBossState && currentBossState.isVisible && !currentBossState.clickedAway && Date.now() > currentBossState.scoldEndTime) {
              setBoss(b => b && b.id === currentBossState.id ? { ...b, clickedAway: true, isVisible: false } : b);
              setTimeout(() => {
                setBoss(cb => (cb && cb.id === currentBossState.id && cb.clickedAway) ? null : cb); 
              }, 1000); 
            }
          }, 3000); 
          return () => { clearInterval(bossInterval); };
        }, [gameStatus, boss, settings, timeLeft]); 

        useEffect(() => {
          if (gameJustEndedRef.current) {
            if (gameStatus === GameStatus.Won) { 
              console.log("[ÊéíË°åÊ¶ú] Ê∏∏ÊàèËÉúÂà©! Ê∑ªÂä†ÂàÜÊï∞Âà∞ÊéíË°åÊ¶ú„ÄÇ");
              // ÂÅúÊ≠¢ÊâÄÊúâËÉåÊôØÈü≥‰πêÂíåÊâìÂ≠óÈü≥ÊïàÂ∑≤Âú®‰∏ªËÉåÊôØÈü≥‰πêÊéßÂà∂useEffect‰∏≠Â§ÑÁêÜ
              typingSoundRef.current?.pause();
              if(typingSoundRef.current && typingSoundRef.current.readyState > 0) typingSoundRef.current.currentTime = 0;
              
              console.log("Â∞ùËØïÊí≠ÊîæËÉúÂà©Èü≥Êïà„ÄÇ");
              winSoundRef.current?.play().catch(e => console.error("Êí≠ÊîæËÉúÂà©Èü≥ÊïàÂ§±Ë¥•:", e));
              
              gameJustEndedRef.current = false; 
              const finalPlayerName = playerName || 'ÂåøÂêçÁé©ÂÆ∂';
              setLeaderboard(prevLeaderboard => {
                const updatedLeaderboard = addScoreToLeaderboardList(finalPlayerName, score, prevLeaderboard);
                saveLeaderboardToAPI(updatedLeaderboard);
                saveLeaderboardToLocalStorage(updatedLeaderboard); 
                return updatedLeaderboard;
              });
            } else if (gameStatus === GameStatus.Lost) {
              console.log("[ÊéíË°åÊ¶ú] Ê∏∏ÊàèÂ§±Ë¥•! ÂàÜÊï∞Êú™Ê∑ªÂä†Âà∞ÊéíË°åÊ¶ú„ÄÇ");
              typingSoundRef.current?.pause();
              if(typingSoundRef.current && typingSoundRef.current.readyState > 0) typingSoundRef.current.currentTime = 0;

              console.log("Â∞ùËØïÊí≠ÊîæÂ§±Ë¥•Èü≥Êïà„ÄÇ");
              loseSoundRef.current?.play().catch(e => console.error("Êí≠ÊîæÂ§±Ë¥•Èü≥ÊïàÂ§±Ë¥•:", e));
              
              gameJustEndedRef.current = false; 
            }
          }
        }, [gameStatus, score, playerName]); 
        
        const handleMosquitoSwat = useCallback((id) => { 
          if (gameStatus !== GameStatus.Playing || !hasInteracted) return;
          console.log("Â§ÑÁêÜËöäÂ≠êÊãçÊâì‰∫ã‰ª∂„ÄÇ");
          playSoundFromPool(swatSoundPoolRef, currentSwatSoundIndexRef);

          let scoreIncrement = 1; 
          const swattedMosquito = mosquitoes.find(m => m.id === id);
          
          if (swattedMosquito && swattedMosquito.type === 'red') {
            scoreIncrement = 2; 
          }

          setScore(s => s + scoreIncrement);
          setMosquitoes(prev => prev.map(m => (m.id === id ? { ...m, isSwatted: true } : m))); 
          setTimeout(() => setMosquitoes(prev => prev.filter(m => m.id !== id)), 300);
        }, [gameStatus, mosquitoes, hasInteracted]); 

        const handleMosquitoReachTarget = useCallback((reachedMosquito) => { 
          if (gameStatus !== GameStatus.Playing || !hasInteracted) return;
          console.log("Â§ÑÁêÜËöäÂ≠êÂà∞ËææÁõÆÊ†á‰∫ã‰ª∂„ÄÇ");
          playSoundFromPool(biteSoundPoolRef, currentBiteSoundIndexRef);

          setMosquitoes(prev => prev.filter(m => m.id !== reachedMosquito.id));
          setIsBittenCooldown(Date.now() + BITE_EFFECT_DURATION_MS);
          setScore(s => Math.max(0, s - settings.mosquitoBiteScorePenalty));
          if (reachedMosquito.type === 'red') { setProgress(p => Math.max(0, p - settings.redMosquitoProgressPenalty)); }
        }, [gameStatus, settings, BITE_EFFECT_DURATION_MS, hasInteracted]);

        const handleBossClick = useCallback((id) => { 
          if (gameStatus !== GameStatus.Playing) return;
          setBoss(b => b && b.id === id ? { ...b, clickedAway: true, isVisible: false, isScolding: false } : b); 
          setScore(s => s + 5); 
          setTimeout(() => {
            setBoss(b => (b && b.id === id && b.clickedAway) ? null : b);
          }, 1000);
        }, [gameStatus]);

        const writerActualPos = { x: window.innerWidth * (WRITER_POSITION.x / 100), y: window.innerHeight * (WRITER_POSITION.y / 100) };
        
        // Áî®‰∫éËß¶ÂèëÈ¶ñÊ¨°Áî®Êà∑‰∫§‰∫íÁöÑÂÖ®Â±ÄÁÇπÂáªÁõëÂê¨Âô®
        useEffect(() => {
            const handleFirstInteraction = () => {
                markUserInteraction();
                window.removeEventListener('click', handleFirstInteraction, true);
                window.removeEventListener('keydown', handleFirstInteraction, true);
            };

            if (!hasInteracted) {
                // ‰ΩøÁî®ÊçïËé∑Èò∂ÊÆµÁ°Æ‰øùÂ∞ΩÊó©ÊçïËé∑‰∫§‰∫í
                window.addEventListener('click', handleFirstInteraction, true);
                window.addEventListener('keydown', handleFirstInteraction, true);
            }

            return () => {
                window.removeEventListener('click', handleFirstInteraction, true);
                window.removeEventListener('keydown', handleFirstInteraction, true);
            };
        }, [hasInteracted]); // ‰æùËµñ hasInteracted

        return React.createElement('div', { className: "relative w-screen h-screen overflow-hidden bg-gradient-to-br from-slate-200 to-slate-400 select-none" },
          gameStatus === GameStatus.Playing && React.createElement(React.Fragment, null,
            React.createElement('div', { className: "absolute top-4 left-4 right-4 p-4 bg-slate-800/70 backdrop-blur-md rounded-lg shadow-xl z-30" },
              React.createElement('div', { className: "flex justify-between items-center text-lg md:text-xl" }, React.createElement(TimerDisplay, { timeLeft: timeLeft }), React.createElement('div', { className: "text-amber-300" }, `ÂàÜÊï∞: ${score}`)),
              React.createElement(ProgressBar, { progress: progress })
            ),
            React.createElement(TenderWriter, { playerName: playerName, position: WRITER_POSITION, isBitten: Date.now() < isBittenCooldown, isTyping: isCurrentlyTyping }),
            mosquitoes.map(mosquito => React.createElement(MosquitoComponent, { key: mosquito.id, mosquito: mosquito, onSwat: handleMosquitoSwat, onReachTarget: handleMosquitoReachTarget, targetPosition: writerActualPos, targetRadius: WRITER_HITBOX_RADIUS, speed: mosquito.type === 'red' ? settings.mosquitoSpeed * settings.redMosquitoSpeedMultiplier : settings.mosquitoSpeed })),
            boss && React.createElement(BossComponent, { bossData: boss, onClick: handleBossClick, playerName: playerName })
          ),
          (gameStatus === GameStatus.Idle || gameStatus === GameStatus.Setup || gameStatus === GameStatus.Won || gameStatus === GameStatus.Lost) && 
            React.createElement(GameOverlay, { status: gameStatus, score: score, onSubmitSetup: handleSubmitSetup, onReturnToSetup: handleReturnToSetup, leaderboard: leaderboard })
        );
      };
      ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App, null));
    </script>
</body>
</html>
--- END OF FILE index.html ---